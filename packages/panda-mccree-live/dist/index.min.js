/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};!function(e,o){"function"==typeof e.define&&e.define.amd?e.define(["PandaMccreeLive"],o):"object"===( false?"undefined":_typeof(exports))?module.exports=o(e.PandaMccreeLive):e.PandaMccreeLive=o(e.PandaMccreeLive),e.PandaMccreeLive=o(e.PandaMccreeLive)}("undefined"==typeof window?global:window,function(e){return e=__webpack_require__(1).default});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function _classCallCheck(e,r){if(!(e instanceof r))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(e,r){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!r||"object"!=typeof r&&"function"!=typeof r?e:r}function _inherits(e,r){if("function"!=typeof r&&null!==r)throw new TypeError("Super expression must either be null or a function, not "+typeof r);e.prototype=Object.create(r&&r.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),r&&(Object.setPrototypeOf?Object.setPrototypeOf(e,r):e.__proto__=r)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.PandaMccreeLive=void 0;var _createClass=function(){function e(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(r,t,o){return t&&e(r.prototype,t),o&&e(r,o),r}}(),_mccreeCore=__webpack_require__(2),_mccreeCore2=_interopRequireDefault(_mccreeCore),_mccreeLoaderFetch=__webpack_require__(9),_mccreeLoaderFetch2=_interopRequireDefault(_mccreeLoaderFetch),_mccreeLoaderMozXhr=__webpack_require__(11),_mccreeLoaderMozXhr2=_interopRequireDefault(_mccreeLoaderMozXhr),_mccreePluginMse=__webpack_require__(12),_mccreePluginMse2=_interopRequireDefault(_mccreePluginMse),_mccreeHelperBrowser=__webpack_require__(13),_mccreeHelperBrowser2=_interopRequireDefault(_mccreeHelperBrowser),_mccreeDemuxerFlv=__webpack_require__(14),_mccreeDemuxerFlv2=_interopRequireDefault(_mccreeDemuxerFlv),_mccreeRemuxerMp4live=__webpack_require__(21),_mccreeRemuxerMp4live2=_interopRequireDefault(_mccreeRemuxerMp4live),PandaMccreeLive=exports.PandaMccreeLive=function(e){function r(e,t){_classCallCheck(this,r);var o=_mccreeHelperBrowser2.default.uaMatch(navigator.userAgent),i=null;i=o.mozilla?new _mccreeLoaderMozXhr2.default:new _mccreeLoaderFetch2.default;var n=new _mccreeDemuxerFlv2.default,a=new _mccreeRemuxerMp4live2.default;t=t||{},t.autoReload||(t.autoReload=6e3),t.loaderBufferLimit=t.loaderBufferLimit||5e7;var c=null;e.logger&&(c=e.logger);var l=_possibleConstructorReturn(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,{logger:c,loader:i,demux:n,remux:a},t));l.TAG="panda-mccree-live",l.logger.debug(l.TAG,"Live initialization");var u=l;return l.observer.on("METADATA_CHANGED",function(){u.reloading||u.reload.call(u)}),l.initStatistic(),l.version="1.1.1-0",l.logger.info(l.TAG,"Current version: "+l.version),l.mseController=new _mccreePluginMse2.default,l.mseController.init(l),l.on=l.observer.on,l}return _inherits(r,e),_createClass(r,[{key:"isSupport",value:function(){return!0}},{key:"checkState",value:function(){this.reloading||this.mseController.checkState()}},{key:"clearBuffer",value:function(){this.mseController.clearBuffer()}},{key:"load",value:function(e){this.logger.info(this.TAG,"loadurl "+e),this.originUrl=e,this.loader.load(e)}},{key:"play",value:function(){this.mediaElement.play()}},{key:"destroy",value:function(){var e=this,r=this;this.logger.debug(r.TAG,"Live destroying"),this.off();var t=new Promise(function(t,o){clearInterval(r.statisticTimmer),r.statisticTimmer=null,r.unload().then(function(o){return e.mediaSource&&e.asourceBuffer&&e.vsourceBuffer?(r.mseController.destroy(),r.detachMedia(),e.media=null,r.cdnip=null,r.loader=null,r.remux=null,r.demux=null,r.logger.debug(r.TAG,"Live destroyed"),void t("destroyed")):void t("already destroyed")}).catch(function(e){t("destroyed")})});return t}},{key:"pause",value:function(){this.mseController.pause()}},{key:"reload",value:function(){var e=this.originUrl,r=this.getMediaElement(),t=this;return t.reloading=!0,new Promise(function(o,i){t.loader.unload().then(function(i){t.mseController.detachMediaElement(),t.media.tracks={},t.remuxBuffer={audio:[],video:[]},t.loaderBuffer.clear(),t.demux.reset(),t.remux.destroy(),t.mseController.removeSourceBuffer(),t.mseController.attachMediaElement(r),t.loader.load(e),t.reloading=!1,o()}).catch(function(e){t.reloading=!1,o()})})}},{key:"getMediaElement",value:function(){return this.mseController.mediaElement}},{key:"initStatistic",value:function(){this.loadbytes=0,this.droppedFrames=0,this.decodedFrames=0;var e=this;this.observer.on(this.events.events.FRAG_LOADED,function(r){e.loadbytes+=r}),this.observer.on("MEDIA_SEGMENT_REMUXED",function(r){r&&(e.decodedFrames+=r)}),this.observer.on("FRAME_DROPPED",function(r){r&&(e.droppedFrames+=r)}),this.statisticTimmer=setInterval(this._onStatistic.bind(this),1e3)}},{key:"_onStatistic",value:function(){try{this.statisticTimmer&&(this.observer.trigger("statistics_info",{droppedFrames:this.droppedFrames,decodedFrames:this.decodedFrames+this.droppedFrames,speed:Math.floor(this.loadbytes/1e3)}),this.loadbytes=0)}catch(e){}}},{key:"attachMediaElement",value:function(e){e&&this.mseController.attachMediaElement(e)}},{key:"recordStartTime",value:function(){this.startTime||(this.startTime=(new Date).getTime())}},{key:"detachMediaElement",value:function(){this.mseController.detachMediaElement()}}]),r}(_mccreeCore2.default);exports.default=PandaMccreeLive;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mccreeHelperLogger = __webpack_require__(3);

	var _mccreeHelperLogger2 = _interopRequireDefault(_mccreeHelperLogger);

	var _events = __webpack_require__(4);

	var _events2 = _interopRequireDefault(_events);

	var _media = __webpack_require__(5);

	var _media2 = _interopRequireDefault(_media);

	var _events3 = __webpack_require__(6);

	var _events4 = _interopRequireDefault(_events3);

	var _mccreeCoreLoaderbuffer = __webpack_require__(7);

	var _mccreeCoreLoaderbuffer2 = _interopRequireDefault(_mccreeCoreLoaderbuffer);

	var _mccreeHelperUtils = __webpack_require__(8);

	var _mccreeHelperUtils2 = _interopRequireDefault(_mccreeHelperUtils);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The main class to create an decoder.
	 */
	var Mccree = function () {
	  /**
	   * The constructor.
	   */
	  function Mccree(modules, config, plugins) {
	    _classCallCheck(this, Mccree);

	    if (!modules) {
	      modules = {};
	    }

	    this.TAG = 'Mccree-core';

	    this.config = config ? config : {};

	    this.debug = config && config.debug || false;

	    this.plugins = plugins || [];

	    this.url = null;

	    this.time = 0;

	    this.events = _events4.default;

	    this.logMsgs = _events4.default.logMsgs;

	    Object.assign(this.logMsgs, this.config.logMessages || {});

	    this._initLogger(modules.logger);

	    this.initObserver();

	    // Use default when options do not defined.
	    this.loaderBuffer = new _mccreeCoreLoaderbuffer2.default();
	    this.remuxBuffer = {};
	    this.initSegment = {};

	    this._createModules(modules);
	    this._initModules();

	    var media = new _media2.default();

	    this.attachMedia(media);
	  }

	  /**
	    * The function to destroy mccree.
	    */


	  _createClass(Mccree, [{
	    key: 'destroy',
	    value: function destroy() {
	      var _this = this;

	      // Destroy timer
	      clearInterval(this.timmer);
	      this.timmer = null;
	      return this.unload().then(function (res) {
	        _this.observer = null;
	        _this.detachMedia();
	        _this.media = null;
	        _this.logger.debug(_this.TAG, _this.logMsgs.DESTROY);
	      });
	    }

	    /**
	     * Use to attach the media profile.
	     */

	  }, {
	    key: 'attachMedia',
	    value: function attachMedia(media) {
	      this.detachMedia();
	      this.media = media;
	    }

	    /** 
	     * Use to detach the Media.
	     */

	  }, {
	    key: 'detachMedia',
	    value: function detachMedia() {
	      this.media = null;
	    }

	    /**
	     * Use to attach media element.
	     */

	  }, {
	    key: 'attachMediaElement',
	    value: function attachMediaElement(media) {
	      this.detachMedia();
	      this.mediaElement = media;
	    }

	    /** 
	     * Use to detach  the Media Element.
	     */

	  }, {
	    key: 'detachMediaElement',
	    value: function detachMediaElement() {
	      this.mediaElement = null;
	    }
	    /** 
	     * Load the resource.
	     *
	     * @param {string} url - The resource url.
	     */

	  }, {
	    key: 'load',
	    value: function load(url) {
	      this.logger.inf(this.TAG, 'loadurl ' + url);
	      this.originUrl = url;
	      this.loader.load(url);
	    }

	    /**
	     * Unload the resource.
	     */

	  }, {
	    key: 'unload',
	    value: function unload() {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        if (_this2.loader) {
	          _this2.logger.debug(_this2.TAG, _this2.logMsgs.UNLOADING);
	          _this2.loader.unload().then(function (res) {
	            resolve();
	          }).catch(function (res) {
	            reject(res);
	          });
	        } else {
	          resolve();
	        }
	      });
	    }

	    /**
	     * Initialize the logger for mccree.
	     * 
	     * @param {object} logger - The js object which has required functions for recording logs.
	     */

	  }, {
	    key: '_initLogger',
	    value: function _initLogger(logger) {
	      // init the logger;
	      if (logger && _mccreeHelperLogger2.default.isValid(logger)) {
	        this.logger = new _mccreeHelperLogger2.default(logger, false, this.debug);
	        this.logger.debug(this.TAG, this.logMsgs.INIT_LOGGER_CUSTOM);
	      } else {
	        this.logger = new _mccreeHelperLogger2.default(null, false, this.debug);
	        this.logger.debug(this.TAG, this.logMsgs.INIT_LOGGER_INTERNAL);
	      }
	    }

	    /**
	     * Initialize the eventemitter for the mccree.
	     */

	  }, {
	    key: 'initObserver',
	    value: function initObserver() {
	      // init eventEmitter;
	      var that = this;
	      this.observer = new _events2.default();

	      this.observer.trigger = function trigger(event) {
	        for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          data[_key - 1] = arguments[_key];
	        }

	        if (event !== 'error') {
	          var _that$observer;

	          (_that$observer = that.observer).emit.apply(_that$observer, [event].concat(data));
	        } else {
	          var _that$observer2;

	          (_that$observer2 = that.observer).emit.apply(_that$observer2, ['internalError'].concat(data));
	        }
	      };

	      this.observer.on = function on(event, listener) {
	        if (event !== 'error') {
	          that.observer.addListener(event, listener);
	        } else {
	          that.observer.addListener('internalError', listener);
	        }
	      };

	      this.observer.off = function off(event, cb) {
	        if (!cb) {
	          cb = function cb() {};
	        }
	        if (!event) {
	          that.observer.removeAllListeners();
	          cb();
	        } else if (event !== 'error') {
	          that.observer.removeListener(event, cb);
	        } else {
	          that.observer.removeListener('internalError', cb);
	        }
	      };

	      this.logger.debug(this.TAG, this.logMsgs.INIT_OBSERVER);

	      this.on = this.observer.on.bind(this.observer);
	      this.off = this.observer.off.bind(this.observer);
	      this.trigger = this.observer.trigger.bind(this.observer);
	    }

	    /**
	     * Load and check the loader, demux and remux modules for mccree.
	     *
	     * @params {Object} modules - The js object contains loader, demux and remux objects.
	     */

	  }, {
	    key: '_createModules',
	    value: function _createModules(modules) {
	      if (modules.loader) {
	        this.loader = modules.loader;
	        this.logger.debug(this.TAG, this.logMsgs.INIT_LOADER);
	      } else {
	        this.logger.error(this.TAG, this.logMsgs.INIT_LOADER_FAIL);
	      }

	      if (modules.demux) {
	        this.demux = modules.demux;
	        this.logger.debug(this.TAG, this.logMsgs.INIT_DEMUXER);
	      } else {
	        this.logger.error(this.TAG, this.logMsgs.INIT_DEMUXER_FAILED);
	      }

	      if (modules.remux) {
	        this.remux = modules.remux;
	        this.logger.debug(this.TAG, this.logMsgs.INIT_REMUXER);
	      } else {
	        this.logger.error(this.TAG, this.logMsgs.INIT_REMUXER_FAILED);
	      }
	    }

	    /**
	     * Call the init functions of loader, demux, remux.
	     */

	  }, {
	    key: '_initModules',
	    value: function _initModules() {
	      this.loader && this.loader.init(this);
	      this.demux && this.demux.init(this);
	      this.remux && this.remux.init(this);
	    }
	  }]);

	  return Mccree;
	}();

	exports.default = Mccree;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Logger = function () {
	  /**
	   * A class to manage logger.
	   * 
	   * @class Logger
	   * @param {Object} logger - The customer logger object. 
	   * @param {boolean} disable - If the logger is disabled by default 
	   */
	  function Logger(logger, disable, debuging) {
	    _classCallCheck(this, Logger);

	    this.disabled = disable;
	    this.debuging = debuging;
	    this._logger = logger;
	  }

	  /**
	   * The debug function, it will use window.console.debug() by default.
	   * Level 1
	   * 
	   * @param {string} tag - The tag string. 
	   * @param {string} message - The debug message.
	   */


	  _createClass(Logger, [{
	    key: 'debug',
	    value: function debug(tag, message) {

	      if (this.disabled) {
	        return;
	      }

	      if (!this.debuging) {
	        return;
	      }

	      if (this._logger) {
	        this._logger.debug(tag, message);
	      } else {
	        var time = new Date().toLocaleString();
	        window && window.console && window.console.debug('[' + time + '][' + tag + '] debug: ' + message);
	      }
	    }

	    /**
	     * The log function, it will use window.console.log() by default.
	     * Level 2
	     * 
	     * @param {string} tag - The tag string. 
	     * @param {string} message - The log message.
	     */

	  }, {
	    key: 'log',
	    value: function log(tag, message) {
	      if (this.disabled) {
	        return;
	      }

	      if (this._logger) {
	        this._logger.log(tag, message);
	      } else {
	        var time = new Date().toLocaleString();
	        window && window.console && window.console.log('[' + time + '][' + tag + '] log: ' + message);
	      }
	    }

	    /**
	     * The info function, it will use window.console.info() by default.
	     * Level 3
	     * 
	     * @param {string} tag - The tag string. 
	     * @param {string} message - The info message.
	     */

	  }, {
	    key: 'info',
	    value: function info(tag, message) {

	      if (this.disabled) {
	        return;
	      }
	      if (this._logger) {
	        this._logger.info(tag, message);
	      } else {
	        var time = new Date().toLocaleString();
	        window && window.console && window.console.info('[' + time + '][' + tag + '] info: ' + message);
	      }
	    }
	  }, {
	    key: 'warn',
	    value: function warn(tag, message) {
	      if (this.disabled) {
	        return;
	      }

	      if (this._logger) {
	        this._logger.warn(tag, message);
	      } else {
	        var time = new Date().toLocaleString();
	        window && window.console && window.console.warn('[' + time + '][' + tag + '] warn: ' + message);
	      }
	    }

	    /**
	     * The error function, it will use window.console.error() by default.
	     * Level 4
	     * 
	     * @param {string} tag - The tag string. 
	     * @param {string} message - The error message.
	     */

	  }, {
	    key: 'error',
	    value: function error(tag, message) {
	      if (this.disabled) {
	        return;
	      }

	      if (this._logger) {
	        this._logger.error(tag, message);
	      } else {
	        var time = new Date().toLocaleString();
	        window && window.console && window.console.debug('[' + time + '][' + tag + '] error: ' + message);
	      }
	    }

	    /**
	     * The function to see if the customer logger is valid.
	     * 
	     * @return {boolean} -  If the logger is valid return true, otherwise return false. 
	     */

	  }], [{
	    key: 'isValid',
	    value: function isValid(logger) {
	      return !!logger && !!logger.info && !!logger.log && !!logger.debug && !!logger.error && !!logger.warn;
	    }
	  }]);

	  return Logger;
	}();

	exports.default = Logger;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	'use strict';
	/**
	 * The data struct
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Media = function () {
	  /**
	   * Media include trucks and media informations.
	   * 
	   * @class Media
	   * @param {Object} mccree - mccree object. 
	   * @param {Object} tracks - tracks.
	   */
	  function Media(config, tracks) {
	    _classCallCheck(this, Media);

	    this.TAG = 'MccreeMedia';

	    this.config = config || {};

	    this.level = null;

	    this.tracks = tracks || {};

	    this.mediaInfo = {};
	    this.videoDuration = 0;
	    this.audioDuration = 0;
	  }

	  /**
	   * Initailize all tracks.
	   */


	  _createClass(Media, [{
	    key: 'initTracks',
	    value: function initTracks() {
	      for (var i = 0; i < this.tracks.length; i++) {
	        this.tracks[Object.keys(this.tracks)[i]].reset();
	      }
	    }
	    /**
	     * reset all tracks.
	     */

	  }, {
	    key: 'resetTracks',
	    value: function resetTracks() {
	      for (var i = 0; i < this.tracks.length; i++) {
	        this.tracks[Object.keys(this.tracks)[i]].reset();
	      }
	    }

	    /**
	     * get a track.
	     *
	     * @param {number} key - the key of track.
	     */

	  }, {
	    key: 'getTrack',
	    value: function getTrack(key) {
	      return this.tracks[key];
	    }

	    /**
	     * destory all tracks.
	     */

	  }, {
	    key: 'destoryTracks',
	    value: function destoryTracks() {
	      for (var i = 0; i < this.tracks.length; i++) {
	        this.tracks[Object.keys(this.tracks)[i]].destroy();
	      }
	    }
	  }]);

	  return Media;
	}();

	exports.default = Media;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var ev = {
	  UNLOAD: 'unload',
	  DESTROY: 'destroy',

	  // mccree-core 
	  MEDIA_ATTACHING: 'mediaAttaching',
	  MEDIA_ATTACHED: 'mediaAttached',
	  MEDIA_DETACHING: 'mediaDetaching',
	  MEDIA_DETACHED: 'mediaDetached',

	  NOT_FOUND: 'notFound',
	  FORBIDDEN: 'forbidden',
	  CONNECTED: 'connected',
	  FRAG_LOADED: 'fragLoaded',
	  FRAG_PARSED: 'fragParsed',
	  FPS_DROP: 'fpsDrop',
	  BUFFER_APPENDING: 'bufferAppending',
	  BUFFER_APPENDED: 'bufferAppended',
	  BUFFER_EOS: 'bufferEos',
	  BUFFER_FLUSHING: 'bufferFlushing',
	  BUFFER_FLUSHED: 'bufferFlushed',

	  // demuxer
	  DEMUXER_MISSMATCH: 'demuxerMissmatch',
	  NO_MEDIA_ATTACHED: 'noMeidaAttached',

	  // remuxer
	  ERROR: 'error'
	};

	var errorTypes = {
	  NETWORK_ERROR: 'NetworkError',
	  MEDIA_ERROR: 'MediaError',
	  MUX_ERROR: 'MuxError',
	  OTHER_ERROR: 'OtherError'
	};

	var errorDetails = {
	  NOT_INITED: 'notInited',

	  NOT_FOUND: 'notFound',
	  FORBIDDEN: 'forbidden',
	  UNKNOWN: 'unknown',

	  DATA_LENGTH_MISSMATCH: 'dataLengthMissMatch'
	};

	var logMessages = {
	  NOT_INITED: 'This module is not init yet',

	  CONNECTED: 'Connected to the source',

	  //Error Messages
	  NOT_FOUND: 'The source is not founded',
	  FORBIDDEN: 'forbidden',
	  UNKNOWN: 'unknown',

	  DESTROY: 'Destroy mccree',
	  UNLOADING: 'Unloading',

	  INIT_OBSERVER: 'Observer initialized',

	  INIT_LOGGER_CUSTOM: 'Logger initialized, use the customer logger',
	  INIT_LOGGER_INTERNAL: 'Logger initialized, use the internal logger',

	  INIT_LOADER: 'Loader initialized',
	  INIT_LOADER_FAIL: 'Loader can not be initialized',

	  INIT_DEMUXER: 'Demuxer initialized',
	  INIT_DEMUXER_FAILED: 'Demuxer can not be initialized',

	  INIT_REMUXER: 'Remuxer initialized',
	  INIT_REMUXER_FAILED: 'Remuxer can not be initialized'
	};

	var events = {
	  events: ev,
	  errorTypes: errorTypes,
	  errorDetails: errorDetails,
	  logMsgs: logMessages
	};

	exports.default = events;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	/**
	 * Copyright [2017] [Shanghai Panda Interactive Entertainment And Culture Company Limited]
	 * 
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 * 
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 * 
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var LoaderBuffer = function () {
	  /**
	   * A buffer to store loaded data.
	   * 
	   * @class LoaderBuffer
	   * @param {number} length - Optional the buffer size 
	   */
	  function LoaderBuffer(length) {
	    _classCallCheck(this, LoaderBuffer);

	    this.length = length ? length : 0;
	    this.array = [];
	    this.offset = 0;
	  }

	  /**
	   * The function to push data.
	   * 
	   * @param {number} data - The data to push into the buffer
	   */


	  _createClass(LoaderBuffer, [{
	    key: 'push',
	    value: function push(data) {
	      this.array.push(data);
	      this.length += data.byteLength;
	    }

	    /**
	     * The function to shift data.
	     * 
	     * @param {number} length - The size of shift.
	     */

	  }, {
	    key: 'shift',
	    value: function shift(length) {
	      if (this.array.length < 1) {
	        return new Uint8Array(0);
	      } else {
	        if (this.offset + length === this.array[0].length) {
	          var _ret = this.array[0].slice(this.offset, this.offset + length);
	          this.offset = 0;
	          this.array.shift();
	          this.length -= length;
	          return _ret;
	        }

	        if (this.offset + length < this.array[0].length) {
	          var _ret2 = this.array[0].slice(this.offset, this.offset + length);
	          this.offset += length;
	          this.length -= length;
	          return _ret2;
	        }

	        var ret = new Uint8Array(length);
	        var tmpoff = 0;
	        while (this.array.length > 0 && length > 0) {
	          if (this.offset + length < this.array[0].length) {
	            var tmp = this.array[0].slice(this.offset, this.offset + length);
	            ret.set(tmp, tmpoff);
	            this.offset += length;
	            this.length -= length;
	            length = 0;
	            break;
	          } else {
	            var templength = this.array[0].length - this.offset;
	            ret.set(this.array[0].slice(this.offset, this.array[0].length), tmpoff);
	            this.array.shift();
	            this.offset = 0;
	            tmpoff += templength;
	            this.length -= templength;
	            length -= templength;
	          }
	        }
	        return ret;
	      }
	    }

	    /**
	     * Function to clear the buffer.
	     */

	  }, {
	    key: 'clear',
	    value: function clear() {
	      this.array = [];
	      this.length = 0;
	      this.offset = 0;
	    }

	    /**
	     * Function to shift one unit8Array.
	     */

	  }, {
	    key: 'shiftBuffer',
	    value: function shiftBuffer() {
	      if (this.array.length > 0) {
	        this.length -= this.array[0].length;
	        this.array.shift();
	        this.offset = 0;
	      }
	    }

	    /**
	     * Convert uint8 data to number.
	     * 
	     * @param {number} start - the start postion.
	     * @param {number} length - the length of data.
	     */

	  }, {
	    key: 'toInt',
	    value: function toInt(start, length) {
	      var retInt = 0;
	      var i = this.offset + start;
	      while (i < this.offset + length + start) {
	        if (i < this.array[0].length) {
	          retInt = retInt * 256 + this.array[0][i];
	        } else if (this.array[1]) {
	          retInt = retInt * 256 + this.array[1][i - this.array[0].length];
	        }

	        i++;
	      }
	      return retInt;
	    }
	  }]);

	  return LoaderBuffer;
	}();

	exports.default = LoaderBuffer;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	/**
	 * Copyright [2017] [Shanghai Panda Interactive Entertainment And Culture Company Limited]
	 * 
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 * 
	 *    http://www.apache.org/licenses/LICENSE-2.0
	 * 
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Utils = exports.Utils = function () {
	  function Utils() {
	    _classCallCheck(this, Utils);
	  }

	  _createClass(Utils, null, [{
	    key: 'getUint',

	    /**
	     * returns a number which is equal to the input.
	     * 返回一个数字，值与输入的UInt8Array相等。
	     * 
	     * @param {Uint8array} uint8array - the Uint8array object.
	     *
	     * @return {Number} - the value of the input. 
	     */
	    value: function getUint(uint8array) {
	      var total = 0;
	      var i = 0;
	      while (i < uint8array.length) {
	        total = total * 256 + uint8array[i];
	        i++;
	      }

	      return total;
	    }

	    /**
	     * This function is called when loader intializing, must bind(this).
	     * 当loader初始化的时候进行调用。必须将this指向绑定。
	     * 
	     * @param {Object} mccree - the mccree core.
	     */

	  }, {
	    key: 'initMccree',
	    value: function initMccree(mccree) {
	      if (!mccree) {
	        throw new Error('mccree is not defined');
	      }
	      if (!mccree.events) {
	        throw new Error('mccree events is not defined');
	      }
	      this.mccree = mccree;
	      this.logger = mccree.logger;
	      this.observer = mccree.observer;
	      this.events = mccree.events.events;
	      this.errorTypes = mccree.events.errorTypes;
	      this.errorDetails = mccree.events.errorDetails;
	      this.logMsgs = mccree.events.logMsgs;
	    }

	    /**
	     * The first object will be extend by the following objects.
	     * 将第一个对象，根据后传入的对象进行扩展。
	     * 
	     * @param {Object} objects - one or more objects.
	     */

	  }, {
	    key: 'extend',
	    value: function extend() {
	      for (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {
	        objects[_key] = arguments[_key];
	      }

	      if (objects.length < 1) {
	        return;
	      }

	      for (var i = 1, len = objects.length; i < len; i++) {
	        var objectKeys = Object.keys(objects[i]);
	        for (var j = 0, length = objectKeys.length; j < length; j++) {
	          objects[0][objectKeys[j]] = objects[i][objectKeys[j]];
	        }
	      }
	    }
	  }]);

	  return Utils;
	}();

	exports.default = Utils;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mccreeControllerLoader = __webpack_require__(10);

	var _mccreeControllerLoader2 = _interopRequireDefault(_mccreeControllerLoader);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FetchLoader = function () {
	  _createClass(FetchLoader, null, [{
	    key: 'isSupported',
	    value: function isSupported() {
	      return !!(self.fetch && self.ReadableStream && Uint8Array);
	    }

	    /**
	     * @constructs
	     *
	     * @param {Object} configs - configs (optional) 设置（可选）。
	     */

	  }]);

	  function FetchLoader(configs) {
	    _classCallCheck(this, FetchLoader);

	    this.TAG = 'Mccree-loader-fetch';
	    this.type = 'loader';
	    this.configs = configs || {};

	    this.status = 0;
	    this.error = null;
	    this._reader = null;
	  }

	  /**
	   * This function is called when loader intializing.
	   * 当loader初始化的时候进行调用。
	   * 
	   * @param {Object} mccree - the mccree core. 麦克雷内核对象。
	   */


	  _createClass(FetchLoader, [{
	    key: 'init',
	    value: function init(mccree) {
	      this.controller = new _mccreeControllerLoader2.default(this);
	      this.controller.init.call(this, mccree);
	    }

	    /**
	     * This function is to load video stream from a source address.
	     * 拉取整段视频流。
	     *
	     * @param {String} source - the source address. 拉流地址。
	     * @param {String} opt - the fetch options. fetch接口拉流属性。
	     * @param {String} range - the stream range. 流片段区间。
	     */

	  }, {
	    key: 'load',
	    value: function load(source, opt, range) {
	      // unload if the loader is loading data.
	      // 如果loader正在获取数据，先进行unload操作。
	      // Declear condition to improve preformance.
	      // 声明清楚执行条件，以提高执行效率。
	      if (this.loading === true) {
	        this.unload();
	      }

	      // clear the loader buffer
	      // 清空loaderbuffer。
	      this.mccree.loaderBuffer.clear();
	      this.loadPartail(source, {
	        start: -1,
	        end: -1
	      }, opt);
	    }

	    /**
	     * This function is to load video stream partially from a source address.
	     * 拉取部分视频流。
	     *
	     * @param {String} source - the source address. 拉流地址。
	     * @param {String} opt - the fetch options. fetch接口拉流属性。
	     * @param {String} range - the stream range. 流片段区间。
	     */

	  }, {
	    key: 'loadPartail',
	    value: function loadPartail(source, range, opts) {
	      // Declear condition to improve preformance.
	      // 声明清楚执行条件，以提高执行效率。
	      if (this.mccree === undefined) {
	        this.logger.warn(this.TAG, 'Live is not init yet');
	        return;
	      }

	      this.source = source;

	      var params = this._getParams(range, opts);
	      var fetchPromise = self.fetch(source, params);
	      var that = this;
	      // fetch is returns a promise in Browsers. resolve when connected or error occured.
	      // fetch 返回一个Promise。当拉到流或异常时释放
	      fetchPromise.then(function (response) {
	        that._status = response.status;
	        that.loading = true;
	        return that._onFetchResponse.call(that, response);
	      }).catch(this._onFetchException.bind(this));
	    }

	    /**
	     * Unload from the current source.
	     * 从当前视频源断流。
	     * 
	     * @return {Promise} - Resolve when disconnected. 断链时释放。
	     */

	  }, {
	    key: 'unload',
	    value: function unload() {
	      var _this = this;

	      var that = this;
	      return new Promise(function (resolve, reject) {
	        if (!that.loading) {
	          resolve();
	        }
	        that.loading = false;
	        that.mccree.loaderBuffer.clear();

	        // declear conditions to improve proformance.
	        // 声明清楚条件，有助于提高执行效率
	        if (that._reader !== undefined) {
	          that._reader.cancel().then(function () {
	            that.loading = false;
	            resolve();
	          });
	        } else {
	          that.loading = false;
	          resolve();
	        }

	        _this.destroyResolve = resolve;
	      });
	    }

	    /**
	     * Construct fetch params.
	     * 构造fetch参数。
	     *
	     * @param {String} opt - the fetch options. fetch接口拉流属性。
	     * @param {String} range - the stream range. 流片段区间。
	     */

	  }, {
	    key: '_getParams',
	    value: function _getParams(range, opts) {
	      var options = opts || {};
	      var headers = new self.Headers();

	      var params = {
	        method: 'GET',
	        headers: headers,
	        mode: 'cors',
	        cache: 'default'
	      };

	      // add custmor headers
	      // 添加自定义头
	      if (_typeof(this.configs.headers) === 'object') {
	        var configHeaders = this.configs.headers;
	        for (var key in configHeaders) {
	          if (configHeaders.hasOwnProperty(key)) {
	            headers.append(key, configHeaders[key]);
	          }
	        }
	      }

	      if (options.cors === false) {
	        params.mode = 'same-origin';
	      }

	      // withCredentials is disabled by default
	      // withCredentials 在默认情况下不被使用。
	      if (options.withCredentials) {
	        params.credentials = 'include';
	      }

	      return params;
	    }

	    /**
	     * Called when fetch has a response.
	     * fetch返回时的回调。
	     *
	     * @param {Object} response - the response. 返回。
	     */

	  }, {
	    key: '_onFetchResponse',
	    value: function _onFetchResponse(response) {
	      this.mccree.url = response.url || this.mccree.url;
	      if (response.ok === true) {
	        this.controller.onConnected.call(this, response);
	        return this._onReader.call(this, response.body.getReader());
	      } else if (response.status == 404) {
	        this.controller.onNotfound.call(this, response);
	      } else if (response.status == 403) {
	        this.controller.onForbidden.call(this, response);
	      } else {
	        this.controller.onUnknownError.call(this, response);
	      }
	    }

	    /**
	     * Called when catches excptions.
	     * 发生异常时的回调。
	     *
	     * @param {Object} error - the error. 错误对象。
	     */

	  }, {
	    key: '_onFetchException',
	    value: function _onFetchException(error) {
	      this.logger.error(this.TAG, this.logMsgs.UNKNOWN);
	      this.observer.trigger('error', this.errorTypes.NETWORK_ERROR, error);
	      return;
	    }

	    /**
	     * The data pumper.
	     * 数据泵。
	     *
	     * @param {Object} reader - the reader. reader对象。
	     */

	  }, {
	    key: '_onReader',
	    value: function _onReader(reader) {
	      this._reader = reader;
	      if (this.loading === false) {
	        return;
	      }

	      var that = this;
	      // reader read function returns a Promise. get data when callback and has value.done when disconnected.
	      // read方法返回一个Promise. 回调中可以获取到数据。当value.done存在时，说明链接断开。
	      this._reader && this._reader.read().then(function (val) {
	        // IMPORTANT: declear conditions to improve proformance.
	        // 重要：声明清楚条件，有助于提高执行效率
	        if (that !== undefined && val.done === true) {
	          that.loading = false;
	          that.logger.debug(that.TAG, 'Loading Finished');
	          if (that.destroyResolve !== undefined) {
	            that.destroyResolve();
	            that.destroyResolve = undefined;
	          } else {
	            that.observer.trigger('error', that.errorTypes.NETWORK_ERROR, that.errorDetails.NOT_FOUND);
	          }

	          return;
	        }

	        that.mccree.loaderBuffer.push(val.value);
	        that.observer.trigger(that.events.FRAG_LOADED, val.value.byteLength);
	        return that._onReader(reader);
	      }).catch(function (error) {
	        that.observer.trigger('error', that.errorTypes.NETWORK_ERROR, error.message);
	      });
	    }
	  }]);

	  return FetchLoader;
	}();

	exports.default = FetchLoader;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * This class is to provide a controller for loaders.
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var LoaderController = function () {
	  /**
	   * @constructs
	   */
	  function LoaderController(loader) {
	    _classCallCheck(this, LoaderController);

	    this.loader = loader;
	    this.loader.loading = false;
	    this.loader.connected = false;

	    this.loader.source = null;
	    this.loader.responseUrl = null;
	    this.loader.cdnip = null;
	  }

	  /**
	   * This function is called when loader intializing, must bind(this).
	   * 当loader初始化的时候进行调用。必须将this指向绑定。
	   * 
	   * @param {Object} mccree - the mccree core.
	   */


	  _createClass(LoaderController, [{
	    key: 'init',
	    value: function init(mccree) {
	      this.mccree = mccree;
	      this.logger = mccree.logger;
	      this.observer = mccree.observer;
	      this.events = mccree.events.events;
	      this.errorTypes = mccree.events.errorTypes;
	      this.errorDetails = mccree.events.errorDetails;
	      this.logMsgs = mccree.events.logMsgs;
	    }

	    /**
	     * This function is called when connected.
	     */

	  }, {
	    key: 'onConnected',
	    value: function onConnected() {
	      if (!this.connected) {
	        this.logger.debug(this.TAG, this.logMsgs.CONNECTED);
	      }
	      this.connected = true;
	    }

	    /**
	     * This function is called when data loaded.
	     *
	     * @param {data} the server response.
	     */

	  }, {
	    key: 'onLoadData',
	    value: function onLoadData(data) {
	      this.connected = true;
	      this.loading = true;
	      this.observer.trigger(this.events.FRAG_LOADED, data);
	    }

	    /**
	     * This function is called when the resource is not found.
	     *
	     * @param {response} the server response.
	     */

	  }, {
	    key: 'onNotfound',
	    value: function onNotfound(response) {
	      this.connected = false;
	      this.loading = false;
	      this.logger.error(this.TAG, this.logMsgs.NOT_FOUND);
	      this.observer.trigger('error', this.errorTypes.NETWORK_ERROR, this.errorDetails.NOTFOUND, response);
	    }

	    /**
	     * This function is called when return forbidden.
	     *
	     * @param {response} the server response.
	     */

	  }, {
	    key: 'onForbidden',
	    value: function onForbidden(response) {
	      this.connected = false;
	      this.loading = false;
	      this.logger.error(this.TAG, this.logMsgs.FORBIDDEN);
	      this.observer.trigger('error', this.errorTypes.NETWORK_ERROR, this.errorDetails.NOTFOUND, response);
	    }
	    /**
	     * This function is called when can not conneced.
	     *
	     * @param {response} the server response.
	     */

	  }, {
	    key: 'onUnknownError',
	    value: function onUnknownError(response) {
	      this.connected = false;
	      this.loading = false;
	      this.logger.error(this.loader.TAG, this.logMsgs.NOT_FOUND);
	      this.observer.trigger('error', this.errorTypes.NETWORK_ERROR, this.errorDetails.NOTFOUND, response);
	    }
	  }]);

	  return LoaderController;
	}();

	exports.default = LoaderController;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mccreeControllerLoader = __webpack_require__(10);

	var _mccreeControllerLoader2 = _interopRequireDefault(_mccreeControllerLoader);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var MozXhrLoader = function () {
	  _createClass(MozXhrLoader, null, [{
	    key: 'isSupported',
	    value: function isSupported() {}
	  }]);

	  function MozXhrLoader(config) {
	    _classCallCheck(this, MozXhrLoader);

	    this.TAG = 'Mccree-loader-moz-xhr';
	    this.type = 'loader';
	    this.config = config || {};
	  }

	  _createClass(MozXhrLoader, [{
	    key: 'init',
	    value: function init(mccree) {
	      this.controller = new _mccreeControllerLoader2.default(this);
	      this.controller.init.call(this, mccree);
	    }
	  }, {
	    key: 'load',
	    value: function load(source, opt) {
	      this._cleanLoaderBuffer();
	      this.loadPartail(source, {
	        start: -1,
	        end: -1
	      }, opt);
	    }
	  }, {
	    key: 'loadPartail',
	    value: function loadPartail(source, range, opts) {
	      var _this = this;

	      if (!this.mccree) {
	        this.logger.warn(this.TAG, 'Live is not init yet');
	        return;
	      }

	      this.source = source;
	      this._loading = false;

	      this.xhr = new XMLHttpRequest();
	      var that = this;
	      this.xhr.open("get", source, true);
	      this.xhr.responseType = 'moz-chunked-arraybuffer';
	      this.xhr.onreadystatechange = function (e) {
	        if (_this.status === 200) {
	          that.controller.onConnected.call(that, e);
	        } else if (_this.status === 404) {
	          that.controller.onNotfound.call(that, e);
	        }
	      };
	      this.xhr.onprogress = function (e) {
	        that.mccree.url = _this.xhr.response.url || that.mccree.url;
	        var chunk = e.target.response;
	        that.mccree.loaderBuffer.push(new Uint8Array(chunk));
	        that.observer.trigger(that.events.FRAG_LOADED, chunk.byteLength);
	      };
	      this.xhr.send();
	    }
	  }, {
	    key: 'unload',
	    value: function unload() {
	      var _this2 = this;

	      var that = this;
	      return new Promise(function (resolve, reject) {
	        that._loading = false;
	        that._cleanLoaderBuffer();
	        _this2.xhr.onprogress = null;
	        _this2.xhr.abort();
	        resolve();
	      });
	    }
	  }, {
	    key: '_cleanLoaderBuffer',
	    value: function _cleanLoaderBuffer() {
	      this.mccree.loaderBuffer.clear();
	    }
	  }]);

	  return MozXhrLoader;
	}();

	window.MozXhrLoader = MozXhrLoader;
	exports.default = MozXhrLoader;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var MSEController = function () {
	  function MSEController() {
	    _classCallCheck(this, MSEController);

	    this.TAG = 'Mccree-plugin-mse';
	    this.type = 'plugin';
	    this.mediaSource = new window.MediaSource();
	    this._lastappand = 'audio';
	    this.mediaElement = null;
	    this.seekables = [];
	    this.mccree = null;
	    this.observer = null;
	    this.config = null;
	    this._initAppanded = false;
	    this._lastappand = 'audio';
	    this.mediaElement = null;
	    this.lastSeek = -1;
	    this.startTime = undefined;
	    this._lastClearTime = 0;
	  }

	  _createClass(MSEController, [{
	    key: 'init',
	    value: function init(mccree) {
	      this.mccree = mccree;
	      this.observer = mccree.observer;
	      this.config = mccree.config;
	      this.logger = mccree.logger;
	      this.observer.on('MEDIA_SEGMENT_REMUXED', this._onMediaSegment.bind(this));
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      this.mediaElement.play();
	    }
	  }, {
	    key: 'checkState',
	    value: function checkState() {
	      if (this.config.autoReload > 15e3 && this.mediaElement && this.mediaElement.readyState < 3 && new Date().getTime() - this.startTime - this.mediaElement.currentTime * 1e3 > this.config.autoReload) {
	        var that = this;
	        this.mccree.reload().then(function () {
	          that.startTime = undefined;
	        });
	      }
	      if (this.seekables[this.seekables.length - 1] > this.lastSeek && this.mediaElement && this.mediaElement.readyState === 2 && this.seekables.length > 1) {
	        this.mediaElement.currentTime = this.seekables[this.seekables.length - 1] / 1e3;
	        this.lastSeek = this.seekables[this.seekables.length - 1];
	      }

	      if (this.seekables[this.seekables.length - 1] > this.lastSeek && this.mediaElement && this.mediaElement.readyState === 1 && this.mediaElement.currentTime > 0 && this.seekables.length > 1) {
	        this.mediaElement.currentTime = this.seekables[this.seekables.length - 1] / 1e3;
	        this.lastSeek = this.seekables[this.seekables.length - 1];
	      }

	      if (this.seekables[this.seekables.length - 1] > this.lastSeek && this.mediaElement && this.seekables.length > 1 && this.mediaElement.readyState < 3 && this.mediaElement.currentTime < this.seekables[this.seekables.length - 1] / 1e3 - 10) {
	        this.mediaElement.currentTime = this.seekables[this.seekables.length - 1] / 1e3;
	        this.lastSeek = this.seekables[this.seekables.length - 1];
	        this.logger.debug(this.TAG, 'Chase frame to ' + this.seekables[this.seekables.length - 1] / 1e3);
	      }

	      this._onMediaSegment();
	    }
	  }, {
	    key: 'clearBuffer',
	    value: function clearBuffer() {
	      if (!this.mediaElement) {
	        return;
	      }
	      if ((new Date().getTime() - this.startTime - this._lastClearTime) / 1000 < 30) {
	        return;
	      }

	      // 降低消耗，一分钟取一次差不多了。
	      var playTime = this.mediaElement.currentTime;

	      // 降低消耗，一分钟清一次差不多了。
	      if (playTime - this._lastClearTime < 30) {
	        return;
	      }

	      if (this.asourceBuffer && this.vsourceBuffer && !this.vsourceBuffer.updating && !this.asourceBuffer.updating) {
	        this.vsourceBuffer.remove(this._lastClearTime, playTime - 10);
	        this.asourceBuffer.remove(this._lastClearTime, playTime - 10);
	        this._lastClearTime = playTime - 10;
	        this.logger.debug(this.TAG, 'Cache clear');
	        while (this.seekables && this.seekables.length > 0 && this.seekables[0] / 1e3 < playTime - 10) {
	          this.seekables.shift();
	        }
	      }
	    }
	  }, {
	    key: 'attachMediaElement',
	    value: function attachMediaElement(mediaElement) {
	      this.mediaElement = mediaElement;
	      this.mediaElement.loop = true;
	      this.mediaSourceObjectURL = window.URL.createObjectURL(this.mediaSource);
	      this.mediaElement.src = this.mediaSourceObjectURL;
	      this.mediaElement.onerror = this.onError.bind(this);
	      this.mediaElement.oncanplay = this.recordStartTime.bind(this);
	      this.mediaElement.onstalled = this.checkState.bind(this);
	    }
	  }, {
	    key: 'detachMediaElement',
	    value: function detachMediaElement() {
	      if (this.mediaElement) {
	        this.mediaElement.onerror = null;
	        this.mediaElement.oncanplay = null;
	        this.mediaElement.onstalled = null;
	      }
	    }
	  }, {
	    key: '_onMediaSegment',
	    value: function _onMediaSegment() {
	      // currently the player will play when 500ms data is ready in the buffer.
	      if (!this._initAppanded && this.mccree.remuxBuffer.lastDts > 500) {
	        this._onInitSegment.call(this);
	      }

	      this.clearBuffer.call(this);

	      if (this.mccree.remuxBuffer.video.length < 1 || this.mccree.remuxBuffer.audio.length < 1) {
	        return;
	      }

	      if (this.asourceBuffer && this.vsourceBuffer && !this.vsourceBuffer.updating && !this.asourceBuffer.updating) {
	        try {
	          if (!this.mediaElement.error && this.mccree.remuxBuffer.lastDts > 500) {
	            var vdata = this.mccree.remuxBuffer.video.shift();
	            var adata = this.mccree.remuxBuffer.audio.shift();
	            this.vsourceBuffer.appendBuffer(vdata.data);
	            this.asourceBuffer.appendBuffer(adata.data);
	            if (!this.seekables) {
	              this.seekables = [];
	            }
	            if (vdata.seekable && vdata.timestamp > 0) {
	              this.seekables.push(vdata.timestamp);
	            }
	            this.checkState.bind(this);
	          } else if (this.mediaElement.error) {
	            this.observer.trigger('error', this.events.errorTypes.MEDIA_ERROR, "MediaMSEError", {
	              code: 11
	            });
	          }
	        } catch (e) {
	          if (e.code) {
	            this.observer.trigger('error', this.events.errorTypes.MEDIA_ERROR, "MediaMSEError", {
	              code: 11
	            });
	          }
	          this.logger.error(this.TAG, 'Cache error of ' + e.code);
	        }
	      }
	    }
	  }, {
	    key: '_onInitSegment',
	    value: function _onInitSegment() {
	      this.seekables = [];
	      if (this.mediaSource.readyState !== 'open') {
	        this.mediaSource.addEventListener('sourceopen', this._appendInitSegment.bind(this));
	      } else {
	        this._appendInitSegment();
	      }
	    }
	  }, {
	    key: '_appendInitSegment',
	    value: function _appendInitSegment() {
	      var data = this.mccree.initSegment;
	      if (this._initAppanded || !data) {
	        return;
	      }
	      this._initAppanded = true;
	      this.asourceBuffer = this.mediaSource.addSourceBuffer('audio/mp4;codecs=' + this.mccree.media.tracks.audioTrack.meta.codec);
	      this.asourceBuffer.appendBuffer(data.audio);
	      this.vsourceBuffer = this.mediaSource.addSourceBuffer('video/mp4;codecs=' + this.mccree.media.tracks.videoTrack.meta.codec);
	      this.vsourceBuffer.appendBuffer(data.video);

	      var that = this;
	      that._onMediaSegment();
	      this.asourceBuffer.addEventListener('error', this.onError.bind(this));
	      this.vsourceBuffer.addEventListener('error', this.onError.bind(this));
	      this.mediaSource.addEventListener('error', this.onError.bind(this));
	      this.vsourceBuffer.addEventListener('updateend', this.checkState.bind(this));
	      try {
	        if (this.media && this.media.mediaInfo && this.media.mediaInfo.cdn_ip) {
	          this.mccree.cdnip = this.media.mediaInfo.cdn_ip;
	        } else if (!this.url) {
	          this.mccree.cdnip = '0.0.0.0';
	        } else {
	          var cdnip = this.url.match(/(\d+)\.(\d+)\.(\d+)\.(\d+)/);
	          this.mccree.cdnip = cdnip && cdnip[0];
	        }

	        var audiocodec = '';
	        var videocodec = '';
	        if (!this.mccree.media) {
	          audiocodec = 'Mccree uninitailized';
	        } else if (!this.mccree.media.tracks.audioTrack) {
	          audiocodec = 'ATNF';
	        } else if (!this.mccree.media.tracks.audioTrack.meta) {
	          audiocodec = 'AMNF';
	        } else {
	          audiocodec = this.mccree.media.tracks.audioTrack.meta.codec;
	        }

	        if (!this.mccree.media) {
	          videocodec = '';
	        } else if (!this.mccree.media.tracks.videoTrack) {
	          videocodec = 'VTNF';
	        } else if (!this.mccree.media.tracks.videoTrack.meta) {
	          videocodec = 'VMNF';
	        } else {
	          videocodec = this.mccree.media.tracks.videoTrack.meta.codec;
	        }

	        var info = {
	          mimeType: 'flv;codecs="' + audiocodec + ',' + videocodec + '"',
	          metadata: {
	            encoder: this.mccree.media ? this.mccree.media.mediaInfo.encoder : 'UNKNOWN'
	          },
	          audioChannelCount: this.mccree.media ? this.mccree.media.mediaInfo.audiochannels : 0,
	          audioDataRate: this.mccree.media ? this.mccree.media.mediaInfo.audiodatarate : 0,
	          audioSampleRate: this.mccree.media ? this.mccree.media.mediaInfo.audiosamplerate : 0,
	          fps: this.mccree.media ? this.mccree.media.tracks.videoTrack.meta.frameRate.fps : 0,
	          videoDataRate: this.mccree.media ? this.mccree.media.mediaInfo.videodatarate : 0,
	          height: this.mccree.media ? this.mccree.media.mediaInfo.height : 0,
	          width: this.mccree.media ? this.mccree.media.mediaInfo.width : 0,
	          cdnip: this.mccree.media ? this.mccree.media.mediaInfo.cdn_ip : this.mccree.cdnip
	        };
	        this.observer.trigger('media_info', info);
	      } catch (e) {}
	    }
	  }, {
	    key: 'pause',
	    value: function pause() {
	      this.mediaElement.pause();
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      if (!this.mediaSource || !this.asourceBuffer || !this.vsourceBuffer) {
	        return;
	      }
	      this.removeSourceBuffer();
	      this.detachMediaElement();
	      this.asourceBuffer = null;
	      this.vsourceBuffer = null;
	      this.mediaSource = null;
	      this._lastClearTime = 0;
	      this.seekables = [];
	    }
	  }, {
	    key: 'removeSourceBuffer',
	    value: function removeSourceBuffer() {
	      this._initAppanded = false;
	      this.mediaElement.pause();
	      URL.revokeObjectURL(this.mediaElement.src);
	      this.asourceBuffer && this.asourceBuffer.removeEventListener('error', this.onError.bind(this));
	      this.vsourceBuffer && this.vsourceBuffer.removeEventListener('error', this.onError.bind(this));
	      this.vsourceBuffer && this.vsourceBuffer.removeEventListener('updateend', this.checkState.bind(this));
	      if (this.mediaSource && this.mediaSource.sourceBuffers.length > 1) {
	        this.mediaSource.removeSourceBuffer(this.asourceBuffer);
	        this.mediaSource.removeSourceBuffer(this.vsourceBuffer);
	      }
	    }
	  }, {
	    key: 'onError',
	    value: function onError(error) {
	      // mediaError一般会一直报。此时肯能已经销毁准备换Flash。不一定还有mediaElment
	      if (this.mediaElement && this.mediaElement.error && !this.reloading) {
	        this.observer.trigger('error', this.events.errorTypes.MEDIA_ERROR, "MediaMSEError", {
	          code: 11
	        });
	      } else {
	        this.observer.trigger('error', this.events.errorTypes.OtherError, this.events.errorDetails.UNKNOWN);
	      }
	    }
	  }, {
	    key: 'recordStartTime',
	    value: function recordStartTime() {
	      if (!this.startTime) {
	        this.startTime = new Date().getTime();
	      }
	    }
	  }]);

	  return MSEController;
	}();

	exports.default = MSEController;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Browser = function () {
	  function Browser() {
	    _classCallCheck(this, Browser);
	  }

	  _createClass(Browser, null, [{
	    key: "uaMatch",
	    value: function uaMatch(ua) {
	      // If an UA is not provided, default to the current browser UA.
	      if (ua === undefined) {
	        ua = window.navigator.userAgent;
	      }
	      ua = ua.toLowerCase();

	      var match = /(edge)\/([\w.]+)/.exec(ua) || /(opr)[\/]([\w.]+)/.exec(ua) || /(chrome)[ \/]([\w.]+)/.exec(ua) || /(iemobile)[\/]([\w.]+)/.exec(ua) || /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];

	      var platform_match = /(ipad)/.exec(ua) || /(ipod)/.exec(ua) || /(windows phone)/.exec(ua) || /(iphone)/.exec(ua) || /(kindle)/.exec(ua) || /(silk)/.exec(ua) || /(android)/.exec(ua) || /(win)/.exec(ua) || /(mac)/.exec(ua) || /(linux)/.exec(ua) || /(cros)/.exec(ua) || /(playbook)/.exec(ua) || /(bb)/.exec(ua) || /(blackberry)/.exec(ua) || [];

	      var browser = {},
	          matched = {
	        browser: match[5] || match[3] || match[1] || "",
	        version: match[2] || match[4] || "0",
	        versionNumber: match[4] || match[2] || "0",
	        platform: platform_match[0] || ""
	      };

	      if (matched.browser) {
	        browser[matched.browser] = true;
	        browser.version = matched.version;
	        browser.versionNumber = parseInt(matched.versionNumber, 10);
	      }

	      if (matched.platform) {
	        browser[matched.platform] = true;
	      }

	      // These are all considered mobile platforms, meaning they run a mobile browser
	      if (browser.android || browser.bb || browser.blackberry || browser.ipad || browser.iphone || browser.ipod || browser.kindle || browser.playbook || browser.silk || browser["windows phone"]) {
	        browser.mobile = true;
	      }

	      // These are all considered desktop platforms, meaning they run a desktop browser
	      if (browser.cros || browser.mac || browser.linux || browser.win) {
	        browser.desktop = true;
	      }

	      // Chrome, Opera 15+ and Safari are webkit based browsers
	      if (browser.chrome || browser.opr || browser.safari) {
	        browser.webkit = true;
	      }

	      // IE11 has a new token so we will assign it msie to avoid breaking changes
	      if (browser.rv || browser.iemobile) {
	        var ie = "msie";

	        matched.browser = ie;
	        browser[ie] = true;
	      }

	      // Edge is officially known as Microsoft Edge, so rewrite the key to match
	      if (browser.edge) {
	        delete browser.edge;
	        var msedge = "msedge";

	        matched.browser = msedge;
	        browser[msedge] = true;
	      }

	      // Blackberry browsers are marked as Safari on BlackBerry
	      if (browser.safari && browser.blackberry) {
	        var blackberry = "blackberry";

	        matched.browser = blackberry;
	        browser[blackberry] = true;
	      }

	      // Playbook browsers are marked as Safari on Playbook
	      if (browser.safari && browser.playbook) {
	        var playbook = "playbook";

	        matched.browser = playbook;
	        browser[playbook] = true;
	      }

	      // BB10 is a newer OS version of BlackBerry
	      if (browser.bb) {
	        var bb = "blackberry";

	        matched.browser = bb;
	        browser[bb] = true;
	      }

	      // Opera 15+ are identified as opr
	      if (browser.opr) {
	        var opera = "opera";

	        matched.browser = opera;
	        browser[opera] = true;
	      }

	      // Stock Android browsers are marked as Safari on Android.
	      if (browser.safari && browser.android) {
	        var android = "android";

	        matched.browser = android;
	        browser[android] = true;
	      }

	      // Kindle browsers are marked as Safari on Kindle
	      if (browser.safari && browser.kindle) {
	        var kindle = "kindle";

	        matched.browser = kindle;
	        browser[kindle] = true;
	      }

	      // Kindle Silk browsers are marked as Safari on Kindle
	      if (browser.safari && browser.silk) {
	        var silk = "silk";

	        matched.browser = silk;
	        browser[silk] = true;
	      }

	      // Assign the name and platform variable
	      browser.name = matched.browser;
	      browser.platform = matched.platform;
	      return browser;
	    }
	  }]);

	  return Browser;
	}();

	exports.default = Browser;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mccreeCoreTrack = __webpack_require__(15);

	var _mccreeHelperSpsparser = __webpack_require__(16);

	var _mccreeHelperSpsparser2 = _interopRequireDefault(_mccreeHelperSpsparser);

	var _defaultVideoConfig = __webpack_require__(18);

	var _defaultVideoConfig2 = _interopRequireDefault(_defaultVideoConfig);

	var _defaultAudioConfig = __webpack_require__(19);

	var _defaultAudioConfig2 = _interopRequireDefault(_defaultAudioConfig);

	var _amfParser = __webpack_require__(20);

	var _amfParser2 = _interopRequireDefault(_amfParser);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FLVDemuxer = function () {
	  /**
	   * Constructor
	   */
	  function FLVDemuxer(config) {
	    _classCallCheck(this, FLVDemuxer);

	    this.TAG = 'mccree-demuxer-flv:index';
	    this.type = 'demuxer';
	    this._isFlv = false;
	    this._config = config || {};
	    this._firstFragLoaded = false;
	    this._hasScript = false;
	    this._hasAudioSequence = false;
	    this._hasVideoSequence = false;
	    this._tracknum = 0;
	  }

	  _createClass(FLVDemuxer, [{
	    key: 'reset',
	    value: function reset() {
	      this._isReseting = true;
	      this._isFlv = false;
	      this._firstFragLoaded = false;
	      this._hasScript = false;
	      this._hasAudioSequence = false;
	      this._hasVideoSequence = false;
	      this._tracknum = 0;
	    }

	    /**
	     * Initailize the demux module.
	     */

	  }, {
	    key: 'init',
	    value: function init(mccree) {
	      this.mccree = mccree;
	      this.logger = mccree.logger;
	      this.observer = mccree.observer;
	      this.events = mccree.events.events;
	      this.errorTypes = mccree.events.errorTypes;
	      this.errorDetails = mccree.events.errorDetails;
	      this.logMsgs = mccree.events.logMsgs;
	      this.observer.on(this.events.FRAG_LOADED, this._fragLoaded.bind(this));
	    }

	    /**
	     * Analyse and appand data when the fragment data is arrival.
	     */

	  }, {
	    key: '_fragLoaded',
	    value: function _fragLoaded() {
	      if (!this._firstFragLoaded) {
	        if (this.mccree.loaderBuffer.length < 13) {
	          return;
	        }
	        var playType = this._config.playType;
	        var data = this.mccree.loaderBuffer.shift(13);
	        this._parseFlvHeader(data, playType);
	        this._fragLoaded();
	      } else {
	        if (this.mccree.loaderBuffer.length < 11) {
	          return;
	        }
	        var chunk = this._parseFlvTag();
	        if (chunk) {
	          if (chunk !== -1) {
	            this.logger.error(this.TAG, 'chunk error');
	          }
	          this._fragLoaded();
	        }
	      }
	    }

	    /**
	     * Parse the flv header.
	     */

	  }, {
	    key: '_parseFlvHeader',
	    value: function _parseFlvHeader(data, playType) {
	      var offset = 0;
	      if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {
	        this.observer.trigger(this.events.demux.DEMUXER_MISSMATCH, data);
	        this._fragLoaded();
	      } else {
	        this._firstFragLoaded = true;
	        offset += 4;
	        var trackInfo = this._switchPlayType(data[offset], playType);
	        if (trackInfo & 0x01 > 0) {
	          this._tracknum++;
	          var videoTrack = new _mccreeCoreTrack.VideoTrack();
	          this.mccree.media.tracks.videoTrack = videoTrack;
	          this._setDefaultVideoConfig();
	        }

	        if (trackInfo & 0x04 > 0) {
	          this._tracknum++;
	          var audioTrack = new _mccreeCoreTrack.AudioTrack();
	          this.mccree.media.tracks.audioTrack = audioTrack;
	          this._setDefaultAudioConfig();
	        }
	        this._fragLoaded();
	      }
	    }

	    /**
	     * If the stream has audio or video. 
	     * @param {numeber} streamFlag - Data from the stream which is define whether the audio / video track is exist. 
	     * @param {String} playType - Defined by the customer. Optional. 
	     */

	  }, {
	    key: '_switchPlayType',
	    value: function _switchPlayType(streamFlag, playType) {
	      var trackInfo = 0x05;
	      switch (playType) {
	        case 'audio':
	          trackInfo = 0x04;
	          break;
	        case 'video':
	          trackInfo = 0x05;
	          break;
	        default:
	          streamFlag ? trackInfo = streamFlag : trackInfo = 0x05;
	          break;
	      }
	      return trackInfo;
	    }

	    /** 
	     * Set the default video configurations. 
	     */

	  }, {
	    key: '_setDefaultVideoConfig',
	    value: function _setDefaultVideoConfig() {
	      var videoTrack = this.mccree.media.tracks.videoTrack;
	      videoTrack.meta = _defaultVideoConfig2.default;
	      videoTrack.id = videoTrack.meta.id = this._tracknum;
	    }

	    /** 
	     * Set the default video configurations. 
	     */

	  }, {
	    key: '_setDefaultAudioConfig',
	    value: function _setDefaultAudioConfig() {
	      var audioTrack = this.mccree.media.tracks.audioTrack;
	      audioTrack.meta = _defaultAudioConfig2.default;
	      audioTrack.id = audioTrack.meta.id = this._tracknum;
	    }

	    /**
	     * Package the data as the following data structure
	     * {
	     *    data: Uint8Array. the Stream data.
	     *    info: The first byte info of the Tag.
	     *    tagType: 8、9、18
	     *    timeStamp: the timestemp;
	     * }
	     */

	  }, {
	    key: '_parseFlvTag',
	    value: function _parseFlvTag() {
	      if (this.mccree.loaderBuffer.length < 11) {
	        return null;
	      }
	      var chunk = this._parseFlvTagHeader();
	      if (chunk) {
	        this._processChunk(chunk);
	      }
	    }

	    /** 
	     * Parse the 11 byte tag Header
	     */

	  }, {
	    key: '_parseFlvTagHeader',
	    value: function _parseFlvTagHeader() {
	      var chunk = {};
	      var tagType = this.mccree.loaderBuffer.toInt(0, 1);

	      // 2 bit FMS reserved, 1 bit filtered, 5 bit tag type
	      chunk.filtered = (tagType & 32) >>> 5;
	      chunk.tagType = tagType & 31;

	      // 3 Byte datasize
	      chunk.datasize = this.mccree.loaderBuffer.toInt(1, 3);
	      if (chunk.tagType !== 8 && chunk.tagType !== 9 && chunk.tagType !== 11 && chunk.tagType !== 18 || this.mccree.loaderBuffer.toInt(8, 3) !== 0) {
	        if (this.loaderBuffer && this.loaderBuffer.length > 0) {
	          this.loaderBuffer.shift(1);
	        }
	        this.logger.warn(this.TAG, 'tagType ' + chunk.tagType);
	        return null;
	      }

	      if (this.mccree.loaderBuffer.length < chunk.datasize + 15) {
	        return null;
	      }

	      // read the data.
	      this.mccree.loaderBuffer.shift(4);

	      // 3 Byte timestamp
	      var timestamp = this.mccree.loaderBuffer.toInt(0, 3);
	      this.mccree.loaderBuffer.shift(3);

	      // 1 Byte timestampExt
	      var timestampExt = this.mccree.loaderBuffer.shift(1)[0];
	      if (timestampExt > 0) {
	        timestamp += timestampExt * 0x1000000;
	      }

	      chunk.timestamp = timestamp;

	      // streamId 
	      this.mccree.loaderBuffer.shift(3);
	      return chunk;
	    }
	  }, {
	    key: '_processChunk',
	    value: function _processChunk(chunk) {
	      switch (chunk.tagType) {
	        case 18:
	          this._parseScriptData(chunk);
	          break;
	        case 8:
	          this._parseAACData(chunk);
	          break;
	        case 9:
	          this._parseAVCData(chunk);
	          break;
	        case 11:
	          // for some CDN that did not process the currect RTMP messages
	          this.mccree.loaderBuffer.shift(3);
	          break;
	        default:
	          this.mccree.loaderBuffer.shift(1);
	          break;
	      }
	      this._fragLoaded();
	    }
	  }, {
	    key: '_clearBuffer',
	    value: function _clearBuffer() {
	      this.logger.debug(this.TAG, 'Cache clear');
	    }
	  }, {
	    key: '_parseScriptData',
	    value: function _parseScriptData(chunk) {
	      var audioTrack = this.mccree.media.tracks.audioTrack;
	      var videoTrack = this.mccree.media.tracks.videoTrack;

	      var data = this.mccree.loaderBuffer.shift(chunk.datasize);
	      var mediaInfo = this.mccree.media.mediaInfo = new _amfParser2.default(data).parseMetadata();
	      var validate = this._datasizeValidator(chunk.datasize);
	      if (validate) {
	        this._hasScript = true;
	      }

	      // Edit default meta.
	      if (audioTrack && !audioTrack.hasSpecificConfig) {
	        var meta = audioTrack.meta;
	        if (mediaInfo.audiosamplerate) {
	          meta.audioSampleRate = mediaInfo.audiosamplerate;
	        }

	        if (mediaInfo.audiochannels) {
	          meta.channelCount = mediaInfo.audiochannels;
	        }

	        switch (mediaInfo.audiosamplerate) {
	          case 44100:
	            meta.sampleRateIndex = 4;
	            break;
	          case 22050:
	            meta.sampleRateIndex = 7;
	            break;
	          case 11025:
	            meta.sampleRateIndex = 10;
	            break;
	        }
	      }
	      if (videoTrack && !videoTrack.hasSpecificConfig) {
	        var _meta = videoTrack.meta;
	        if (typeof mediaInfo.framerate === 'number') {
	          var fps_num = Math.floor(mediaInfo.framerate * 1000);
	          if (fps_num > 0) {
	            var fps = fps_num / 1000;
	            if (!_meta.frameRate) {
	              _meta.frameRate = {};
	            }
	            _meta.frameRate.fixed = true;
	            _meta.frameRate.fps = fps;
	            _meta.frameRate.fps_num = fps_num;
	            _meta.frameRate.fps_den = 1000;
	          }
	        }
	      }
	    }
	  }, {
	    key: '_parseAACData',
	    value: function _parseAACData(chunk) {
	      var track = this.mccree.media.tracks.audioTrack;
	      if (!track) {
	        return;
	      }

	      var meta = track.meta;

	      if (!meta) {
	        meta = _defaultAudioConfig2.default;
	      }

	      var info = this.mccree.loaderBuffer.shift(1)[0];

	      chunk.data = this.mccree.loaderBuffer.shift(chunk.datasize - 1);

	      var format = (info & 240) >>> 4;

	      track.format = format;

	      if (format !== 10) {
	        this.observer.trigger('error', this.mccree.events.MEDIA_ERROR, {});
	      }

	      if (format === 10 && !this._hasAudioSequence) {
	        meta.audioSampleRate = this._switchAudioSamplingFrequency(info);
	        meta.sampleRateIndex = (info & 12) >>> 2;
	        meta.frameLenth = (info & 2) >>> 1;
	        meta.channelCount = info & 1;
	        meta.refSampleDuration = Math.floor(1024 / meta.audioSampleRate * meta.timescale);
	      }

	      var audioSampleRate = meta.audioSampleRate;
	      var audioSampleRateIndex = meta.sampleRateIndex;
	      var refSampleDuration = meta.refSampleDuration;

	      delete chunk.tagType;
	      var validate = this._datasizeValidator(chunk.datasize);

	      if (chunk.data[0] === 0) {
	        var ret = this._aacSequenceHeaderParser(chunk.data);
	        audioSampleRate = ret.audiosamplerate || meta.audioSampleRate;
	        audioSampleRateIndex = ret.sampleRateIndex || meta.sampleRateIndex;
	        refSampleDuration = Math.floor(1024 / audioSampleRate * meta.timescale);
	        meta.channelCount = ret.channelCount;
	        meta.audioSampleRate = audioSampleRate;
	        meta.sampleRateIndex = audioSampleRateIndex;
	        meta.refSampleDuration = refSampleDuration;
	        if (this._hasScript && !this._hasAudioSequence && (!this.mccree.media.tracks.videoTrack || this._hasVideoSequence)) {
	          this.observer.trigger('METADATA_PARSED');
	        } else if (this._hasScript && this._hasAudioSequence) {
	          this.observer.trigger('METADATA_CHANGED');
	        }
	        ;
	        this._hasAudioSequence = true;
	      } else {
	        chunk.data = chunk.data.slice(1, chunk.data.length);
	        this.observer.trigger('AUDIODATA_PARSED');
	        track.samples.push(chunk);
	      }

	      if (!validate) {
	        this.logger.warn(this.TAG, 'TAG length error at ' + chunk.datasize);
	      }
	    }
	  }, {
	    key: '_parseAVCData',
	    value: function _parseAVCData(chunk) {

	      // header
	      var info = this.mccree.loaderBuffer.shift(1)[0];
	      chunk.frameType = (info & 0xf0) >>> 4;
	      var codecID = info & 0x0f;
	      this.mccree.media.tracks.videoTrack.codecID = codecID;

	      // AVC or not.
	      if (codecID === 7) {
	        // AVC header.
	        chunk.avcPacketType = this.mccree.loaderBuffer.shift(1)[0];
	        chunk.compositionTime = this.mccree.loaderBuffer.toInt(0, 3);
	        this.mccree.loaderBuffer.shift(3);
	        // 对七牛SDK中AVCC和AnnexB错误混编的兼容。（不影响其他端&SDK编码器及推流)
	        // TODO: 配适其他SDK混编情况

	        var data = this.mccree.loaderBuffer.shift(chunk.datasize - 5);
	        if (data[4] === 0 && data[5] === 0 && data[6] === 0 && data[7] === 1) {
	          var avcclength = 0;
	          for (var i = 0; i < 4; i++) {
	            avcclength = avcclength * 256 + data[i];
	          }
	          avcclength -= 4;
	          data = data.slice(4, data.length);
	          data[3] = avcclength % 256;
	          avcclength = (avcclength - data[3]) / 256;
	          data[2] = avcclength % 256;
	          avcclength = (avcclength - data[2]) / 256;
	          data[1] = avcclength % 256;
	          data[0] = (avcclength - data[1]) / 256;
	        }
	        chunk.data = data;
	        // If it is AVC sequece Header.
	        if (chunk.avcPacketType === 0) {
	          this._avcSequenceHeaderParser(chunk.data);
	          var validate = this._datasizeValidator(chunk.datasize);
	          if (validate) {
	            if (this._hasScript && !this._hasVideoSequence && (!this.mccree.media.tracks.audioTrack || this._hasAudioSequence)) {
	              this.observer.trigger('METADATA_PARSED');
	            } else if (this._hasScript && this._hasVideoSequence) {
	              this.observer.trigger('METADATA_CHANGED');
	            }
	            this._hasVideoSequence = true;
	          }
	        } else {
	          if (!this._datasizeValidator(chunk.datasize)) {
	            this.logger.warn(this.TAG, 'TAG length error at ' + chunk.datasize);
	          }
	          this.observer.trigger('VIDEODATA_PARSED');
	          this.mccree.media.tracks.videoTrack.samples.push(chunk);
	        }
	      } else {
	        chunk.data = this.mccree.loaderBuffer.shift(chunk.datasize - 1);
	        if (!this._datasizeValidator(chunk.datasize)) {
	          this.logger.warn(this.TAG, this.type, 'TAG length error at ' + chunk.datasize);
	        }
	        this.observer.trigger('VIDEODATA_PARSED');
	        this.mccree.media.tracks.videoTrack.samples.push(chunk);
	      }

	      delete chunk.tagType;
	    }
	  }, {
	    key: '_datasizeValidator',
	    value: function _datasizeValidator(datasize) {
	      var datasizeConfirm = this.mccree.loaderBuffer.toInt(0, 4);
	      this.mccree.loaderBuffer.shift(4);
	      var validate = datasizeConfirm === datasize + 11;
	      return validate;
	    }
	  }, {
	    key: '_switchAudioSamplingFrequency',
	    value: function _switchAudioSamplingFrequency(info) {
	      var samplingFrequencyIndex = (info & 12) >>> 2;
	      var samplingFrequencyList = [5500, 11025, 22050, 44100];
	      return samplingFrequencyList[samplingFrequencyIndex];
	    }
	  }, {
	    key: '_switchAudioChannel',
	    value: function _switchAudioChannel(info) {
	      var sampleTrackNumIndex = info & 1;
	      var sampleTrackNumList = [1, 2];
	      return sampleTrackNumList[sampleTrackNumIndex];
	    }
	  }, {
	    key: '_aacSequenceHeaderParser',
	    value: function _aacSequenceHeaderParser(data) {
	      var ret = {};
	      ret.hasSpecificConfig = true;
	      ret.objectType = data[1] >>> 3;
	      ret.sampleRateIndex = (data[1] & 7) << 1 | data[2] >>> 7;
	      ret.audiosamplerate = this._switchAudioSampleRate(ret.sampleRateIndex);
	      ret.channelCount = (data[2] & 120) >>> 3;
	      ret.frameLength = (data[2] & 4) >>> 2;
	      ret.dependsOnCoreCoder = (data[2] & 2) >>> 1;
	      ret.extensionFlagIndex = data[2] & 1;
	      return ret;
	    }
	  }, {
	    key: '_switchAudioSampleRate',
	    value: function _switchAudioSampleRate(samplingFrequencyIndex) {
	      var samplingFrequencyList = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
	      return samplingFrequencyList[samplingFrequencyIndex];
	    }
	  }, {
	    key: '_avcSequenceHeaderParser',
	    value: function _avcSequenceHeaderParser(data) {
	      var track = this.mccree.media.tracks.videoTrack;

	      if (!track) {
	        return;
	      }

	      var offset = 0;

	      if (!track.meta) {
	        track.meta = _defaultVideoConfig2.default;
	      }
	      var meta = track.meta;

	      meta.configurationVersion = data[0];
	      meta.avcProfileIndication = data[1];
	      meta.profileCompatibility = data[2];
	      meta.avcLevelIndication = data[3] / 10;
	      meta.nalUnitLength = (data[4] & 0x03) + 1;

	      var numOfSps = data[5] & 0x1f;
	      offset = 6;
	      var config = {};

	      // parse SPS
	      for (var i = 0; i < numOfSps; i++) {
	        var size = data[offset] * 255 + data[offset + 1];
	        offset += 2;

	        var sps = new Uint8Array(size);
	        for (var _j = 0; _j < size; _j++) {
	          sps[_j] = data[offset + _j];
	        }

	        // codec string
	        var codecString = 'avc1.';
	        for (var j = 1; j < 4; j++) {
	          var h = sps[j].toString(16);
	          if (h.length < 2) {
	            h = '0' + h;
	          }
	          codecString += h;
	        }

	        meta.codec = codecString;

	        offset += size;
	        config = _mccreeHelperSpsparser2.default.parseSPS(sps);
	      }

	      var numOfPps = data[offset];
	      offset++;
	      for (var _i = 0; _i < numOfPps; _i++) {
	        var _size = data[offset] * 255 + data[offset + 1];
	        offset += 2;
	        var pps = new Uint8Array(_size);
	        for (var _j2 = 0; _j2 < _size; _j2++) {
	          pps[_j2] = data[offset + _j2];
	        }
	        offset += _size;
	        this.mccree.media.tracks.videoTrack.pps = pps;
	      }

	      if (config && config.codec_size) {
	        meta.codecWidth = config.codec_size.width;
	        meta.codecHeight = config.codec_size.height;
	        meta.presentWidth = config.present_size.width;
	        meta.presentHeight = config.present_size.height;
	      }

	      meta.profile = config.profile_string || meta.profile;
	      meta.level = config.level_string || meta.level;
	      meta.bitDepth = config.bit_depth || meta.bitDepth;
	      meta.chromaFormat = config.chroma_format || meta.chromaFormat;

	      if (meta.sarRatio) {
	        meta.sarRatio.width = config.sar_ratio.width;
	        meta.sarRatio.height = config.sar_ratio.height;
	      }

	      if (meta.frameRate && config.frame_rate.fixed && config.frame_rate.fps_num > 0 && config.frame_rate.fps_den > 0) {
	        meta.frameRate = config.frame_rate;
	      }

	      var fps_den = meta.frameRate.fps_den;
	      var fps_num = meta.frameRate.fps_num;
	      meta.refSampleDuration = Math.floor(meta.timescale * (fps_den / fps_num));

	      meta.avcc = new Uint8Array(data.length);
	      meta.avcc.set(data);
	      track.meta = meta;
	    }
	  }]);

	  return FLVDemuxer;
	}();

	exports.default = FLVDemuxer;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Track = function () {
	  /**
	   * The constructor.
	   */
	  function Track() {
	    _classCallCheck(this, Track);

	    this.TAG = "Track";
	    this.id = -1;
	    this.sequenceNumber = 0;
	    this.samples = [];
	    this.length = 0;
	  }

	  /**
	   * Reset the track.
	   */


	  _createClass(Track, [{
	    key: "reset",
	    value: function reset() {
	      this.sequenceNumber = 0;
	      this.samples = [];
	      this.length = 0;
	    }
	    /**
	     * destroy the track.
	     */

	  }, {
	    key: "distroy",
	    value: function distroy() {
	      this.reset();
	      this.id = -1;
	    }
	  }]);

	  return Track;
	}();

	exports.default = Track;

	var AudioTrack = exports.AudioTrack = function (_Track) {
	  _inherits(AudioTrack, _Track);

	  /**
	   * The constructor for audio track.
	   */
	  function AudioTrack() {
	    _classCallCheck(this, AudioTrack);

	    var _this = _possibleConstructorReturn(this, (AudioTrack.__proto__ || Object.getPrototypeOf(AudioTrack)).call(this));

	    _this.TAG = "AudioTrack";
	    _this.type = 'audio';
	    return _this;
	  }

	  return AudioTrack;
	}(Track);

	var VideoTrack = exports.VideoTrack = function (_Track2) {
	  _inherits(VideoTrack, _Track2);

	  /**
	   * The constructor for video track.
	   */
	  function VideoTrack() {
	    _classCallCheck(this, VideoTrack);

	    var _this2 = _possibleConstructorReturn(this, (VideoTrack.__proto__ || Object.getPrototypeOf(VideoTrack)).call(this));

	    _this2.TAG = "VideoTrack";
	    _this2.type = 'video';
	    _this2.dropped = 0;
	    return _this2;
	  }
	  /**
	   * reset the video track.
	   */


	  _createClass(VideoTrack, [{
	    key: "reset",
	    value: function reset() {
	      this.sequenceNumber = 0;
	      this.samples = [];
	      this.length = 0;
	      this.dropped = 0;
	    }
	  }]);

	  return VideoTrack;
	}(Track);

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mccreeHelperGolomb = __webpack_require__(17);

	var _mccreeHelperGolomb2 = _interopRequireDefault(_mccreeHelperGolomb);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 *
	 *
	 */
	var SPSParser = function () {
	    function SPSParser() {
	        _classCallCheck(this, SPSParser);
	    }

	    _createClass(SPSParser, null, [{
	        key: '_ebsp2rbsp',
	        value: function _ebsp2rbsp(uint8array) {
	            var src = uint8array;
	            var srcLength = src.byteLength;
	            var dst = new Uint8Array(srcLength);
	            var dstIdx = 0;

	            for (var i = 0; i < srcLength; i++) {
	                if (i >= 2) {
	                    if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {
	                        continue;
	                    }
	                }
	                dst[dstIdx] = src[i];
	                dstIdx++;
	            }

	            return new Uint8Array(dst.buffer, 0, dstIdx);
	        }
	    }, {
	        key: 'parseSPS',
	        value: function parseSPS(uint8array) {
	            var rbsp = SPSParser._ebsp2rbsp(uint8array);
	            var gb = new _mccreeHelperGolomb2.default(rbsp);

	            gb.readByte();
	            var profileIdc = gb.readByte();
	            gb.readByte();
	            var levelIdc = gb.readByte();
	            gb.readUEG();

	            var profile_string = SPSParser.getProfileString(profileIdc);
	            var level_string = SPSParser.getLevelString(levelIdc);
	            var chroma_format_idc = 1;
	            var chroma_format = 420;
	            var chroma_format_table = [0, 420, 422, 444];
	            var bit_depth = 8;

	            if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128 || profileIdc === 138 || profileIdc === 144) {

	                chroma_format_idc = gb.readUEG();
	                if (chroma_format_idc === 3) {
	                    gb.readBits(1);
	                }
	                if (chroma_format_idc <= 3) {
	                    chroma_format = chroma_format_table[chroma_format_idc];
	                }

	                bit_depth = gb.readUEG() + 8;
	                gb.readUEG();
	                gb.readBits(1);
	                if (gb.readBool()) {
	                    var scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;
	                    for (var i = 0; i < scaling_list_count; i++) {
	                        if (gb.readBool()) {
	                            if (i < 6) {
	                                SPSParser._skipScalingList(gb, 16);
	                            } else {
	                                SPSParser._skipScalingList(gb, 64);
	                            }
	                        }
	                    }
	                }
	            }
	            gb.readUEG();
	            var pic_order_cnt_type = gb.readUEG();
	            if (pic_order_cnt_type === 0) {
	                gb.readUEG();4;
	            } else if (pic_order_cnt_type === 1) {
	                gb.readBits(1);
	                gb.readSEG();
	                gb.readSEG();
	                var num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();
	                for (var _i = 0; _i < num_ref_frames_in_pic_order_cnt_cycle; _i++) {
	                    gb.readSEG();
	                }
	            }
	            gb.readUEG();
	            gb.readBits(1);

	            var pic_width_in_mbs_minus1 = gb.readUEG();
	            var pic_height_in_map_units_minus1 = gb.readUEG();

	            var frame_mbs_only_flag = gb.readBits(1);
	            if (frame_mbs_only_flag === 0) {
	                gb.readBits(1);
	            }
	            gb.readBits(1);

	            var frame_crop_left_offset = 0;
	            var frame_crop_right_offset = 0;
	            var frame_crop_top_offset = 0;
	            var frame_crop_bottom_offset = 0;

	            var frame_cropping_flag = gb.readBool();
	            if (frame_cropping_flag) {
	                frame_crop_left_offset = gb.readUEG();
	                frame_crop_right_offset = gb.readUEG();
	                frame_crop_top_offset = gb.readUEG();
	                frame_crop_bottom_offset = gb.readUEG();
	            }

	            var sar_width = 1,
	                sar_height = 1;
	            var fps = 0,
	                fps_fixed = true,
	                fps_num = 0,
	                fps_den = 0;

	            var vui_parameters_present_flag = gb.readBool();
	            if (vui_parameters_present_flag) {
	                if (gb.readBool()) {
	                    // aspect_ratio_info_present_flag
	                    var aspect_ratio_idc = gb.readByte();
	                    var sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];
	                    var sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];

	                    if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {
	                        sar_width = sar_w_table[aspect_ratio_idc - 1];
	                        sar_height = sar_h_table[aspect_ratio_idc - 1];
	                    } else if (aspect_ratio_idc === 255) {
	                        sar_width = gb.readByte() << 8 | gb.readByte();
	                        sar_height = gb.readByte() << 8 | gb.readByte();
	                    }
	                }

	                if (gb.readBool()) {
	                    gb.readBool();
	                }
	                if (gb.readBool()) {
	                    gb.readBits(4);
	                    if (gb.readBool()) {
	                        gb.readBits(24);
	                    }
	                }
	                if (gb.readBool()) {
	                    gb.readUEG();
	                    gb.readUEG();
	                }
	                if (gb.readBool()) {
	                    var num_units_in_tick = gb.readBits(32);
	                    var time_scale = gb.readBits(32);
	                    fps_fixed = gb.readBool();

	                    fps_num = time_scale;
	                    fps_den = num_units_in_tick * 2;
	                    fps = fps_num / fps_den;
	                }
	            }

	            var sarScale = 1;
	            if (sar_width !== 1 || sar_height !== 1) {
	                sarScale = sar_width / sar_height;
	            }

	            var crop_unit_x = 0,
	                crop_unit_y = 0;
	            if (chroma_format_idc === 0) {
	                crop_unit_x = 1;
	                crop_unit_y = 2 - frame_mbs_only_flag;
	            } else {
	                var sub_wc = chroma_format_idc === 3 ? 1 : 2;
	                var sub_hc = chroma_format_idc === 1 ? 2 : 1;
	                crop_unit_x = sub_wc;
	                crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);
	            }

	            var codec_width = (pic_width_in_mbs_minus1 + 1) * 16;
	            var codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);

	            codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;
	            codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;

	            var present_width = Math.ceil(codec_width * sarScale);

	            gb.destroy();
	            gb = null;

	            return {
	                profile_string: profile_string,
	                level_string: level_string,
	                bit_depth: bit_depth,
	                chroma_format: chroma_format,
	                chroma_format_string: SPSParser.getChromaFormatString(chroma_format),

	                frame_rate: {
	                    fixed: fps_fixed,
	                    fps: fps,
	                    fps_den: fps_den,
	                    fps_num: fps_num
	                },

	                sar_ratio: {
	                    width: sar_width,
	                    height: sar_height
	                },

	                codec_size: {
	                    width: codec_width,
	                    height: codec_height
	                },

	                present_size: {
	                    width: present_width,
	                    height: codec_height
	                }
	            };
	        }
	    }, {
	        key: '_skipScalingList',
	        value: function _skipScalingList(gb, count) {
	            var last_scale = 8,
	                next_scale = 8;
	            var delta_scale = 0;
	            for (var i = 0; i < count; i++) {
	                if (next_scale !== 0) {
	                    delta_scale = gb.readSEG();
	                    next_scale = (last_scale + delta_scale + 256) % 256;
	                }
	                last_scale = next_scale === 0 ? last_scale : next_scale;
	            }
	        }
	    }, {
	        key: 'getProfileString',
	        value: function getProfileString(profileIdc) {
	            switch (profileIdc) {
	                case 66:
	                    return 'Baseline';
	                case 77:
	                    return 'Main';
	                case 88:
	                    return 'Extended';
	                case 100:
	                    return 'High';
	                case 110:
	                    return 'High10';
	                case 122:
	                    return 'High422';
	                case 244:
	                    return 'High444';
	                default:
	                    return 'Unknown';
	            }
	        }
	    }, {
	        key: 'getLevelString',
	        value: function getLevelString(levelIdc) {
	            return (levelIdc / 10).toFixed(1);
	        }
	    }, {
	        key: 'getChromaFormatString',
	        value: function getChromaFormatString(chroma) {
	            switch (chroma) {
	                case 420:
	                    return '4:2:0';
	                case 422:
	                    return '4:2:2';
	                case 444:
	                    return '4:4:4';
	                default:
	                    return 'Unknown';
	            }
	        }
	    }]);

	    return SPSParser;
	}();

	exports.default = SPSParser;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// Exponential-Golomb buffer decoder
	var Golomb = function () {
	    function Golomb(uint8array) {
	        _classCallCheck(this, Golomb);

	        this.TAG = 'Golomb';
	        this._buffer = uint8array;
	        this._bufferIndex = 0;
	        this._totalBytes = uint8array.byteLength;
	        this._totalBits = uint8array.byteLength * 8;
	        this._currentWord = 0;
	        this._currentWordBitsLeft = 0;
	    }

	    _createClass(Golomb, [{
	        key: 'destroy',
	        value: function destroy() {
	            this._buffer = null;
	        }
	    }, {
	        key: '_fillCurrentWord',
	        value: function _fillCurrentWord() {
	            var bufferBytesLeft = this._totalBytes - this._bufferIndex;
	            if (bufferBytesLeft <= 0) {
	                // TODO 异常处理
	            }

	            var bytesRead = Math.min(4, bufferBytesLeft);
	            var word = new Uint8Array(4);
	            word.set(this._buffer.subarray(this._bufferIndex, this._bufferIndex + bytesRead));
	            this._currentWord = new DataView(word.buffer).getUint32(0, false);

	            this._bufferIndex += bytesRead;
	            this._currentWordBitsLeft = bytesRead * 8;
	        }
	    }, {
	        key: 'readBits',
	        value: function readBits(bits) {
	            if (bits > 32) {
	                // TODO
	            }

	            if (bits <= this._currentWordBitsLeft) {
	                var _result = this._currentWord >>> 32 - bits;
	                this._currentWord <<= bits;
	                this._currentWordBitsLeft -= bits;
	                return _result;
	            }

	            var result = this._currentWordBitsLeft ? this._currentWord : 0;
	            result >>> 32 - this._currentWordBitsLeft;
	            var bitsNeedLeft = bits - this._currentWordBitsLeft;

	            this._fillCurrentWord();
	            var bitsReadNext = Math.min(bitsNeedLeft, this._currentWordBitsLeft);

	            var result2 = this._currentWord >>> 32 - bitsReadNext;
	            this._currentWord <<= bitsReadNext;
	            this._currentWordBitsLeft -= bitsReadNext;

	            result = result << bitsReadNext | result2;
	            return result;
	        }
	    }, {
	        key: 'readBool',
	        value: function readBool() {
	            return this.readBits(1) === 1;
	        }
	    }, {
	        key: 'readByte',
	        value: function readByte() {
	            return this.readBits(8);
	        }
	    }, {
	        key: '_skipLeadingZero',
	        value: function _skipLeadingZero() {
	            var zeroCount = void 0;
	            for (zeroCount = 0; zeroCount < this._currentWordBitsLeft; zeroCount++) {
	                if (0 !== (this._currentWord & 0x80000000 >>> zeroCount)) {
	                    this._currentWord <<= zeroCount;
	                    this._currentWordBitsLeft -= zeroCount;
	                    return zeroCount;
	                }
	            }
	            this._fillCurrentWord();
	            return zeroCount + this._skipLeadingZero();
	        }
	    }, {
	        key: 'readUEG',
	        value: function readUEG() {
	            // unsigned exponential golomb
	            var leadingZeros = this._skipLeadingZero();
	            return this.readBits(leadingZeros + 1) - 1;
	        }
	    }, {
	        key: 'readSEG',
	        value: function readSEG() {
	            // signed exponential golomb
	            var value = this.readUEG();
	            if (value & 0x01) {
	                return value + 1 >>> 1;
	            } else {
	                return -1 * (value >>> 1);
	            }
	        }
	    }]);

	    return Golomb;
	}();

	exports.default = Golomb;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var defaultVideoConfig = {
	  avcc: null,
	  chromaFormat: 420,
	  codec: 'avc1.640020',
	  codecHeight: 720,
	  codecWidth: 1280,
	  duration: 0,
	  frameRate: {
	    fixed: true,
	    fps: 25,
	    fps_num: 25000,
	    fps_den: 1000
	  },
	  id: 1,
	  level: "3.2",
	  presentHeight: 720,
	  presentWidth: 1280,
	  profile: "High",
	  refSampleDuration: 40,
	  sarRatio: {
	    height: 1,
	    width: 1
	  },
	  timescale: 1000,
	  type: "video"
	};
	exports.default = defaultVideoConfig;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var defaultAudioConfig = {
	  audioSampleRate: 48000,
	  channelCount: 2,
	  codec: "mp4a.40.2",
	  config: [41, 401, 136, 0],
	  duration: 0,
	  id: 2,
	  refSampleDuration: 21,
	  sampleRateIndex: 3,
	  timescale: 1000,
	  type: "audio"
	};

	exports.default = defaultAudioConfig;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var AmfParser = function () {
	  function AmfParser(data) {
	    _classCallCheck(this, AmfParser);

	    this.offset = 0;
	    this.data = data;
	  }

	  _createClass(AmfParser, [{
	    key: 'parseMetadata',
	    value: function parseMetadata() {
	      var metadata = {};
	      try {
	        var scriptData = this.parseAMF();
	        for (var i = 0; i < scriptData.length - 1; i++) {
	          if (typeof scriptData[i] === 'string' && scriptData[i] === 'onMetaData' && _typeof(scriptData[i + 1]) === 'object') {
	            metadata = scriptData[i + 1];
	          }
	        }
	      } catch (e) {
	        // TODO: 异常处理
	      }
	      return metadata;
	    }
	  }, {
	    key: 'parseAMF',
	    value: function parseAMF() {
	      var result = [];

	      // find on metadata 
	      while (this.offset < this.data.length) {
	        var type = this.data[this.offset];
	        this.offset++;
	        var value = this._switchAmfType(type);
	        result.push(value);
	      }
	      return result;
	    }
	    // TODO: implement XML etc.

	  }, {
	    key: '_switchAmfType',
	    value: function _switchAmfType(type) {
	      var value = null;
	      switch (type) {
	        case 0x00:
	          value = this._parseNum();
	          break;
	        case 0x01:
	          value = this._parseBoolean();
	          break;
	        case 0x02:
	          value = this._parseString();
	          break;
	        case 0x03:
	          value = this._parseObject();
	          break;
	        case 0x04:
	          value = 'MovieClip'; //reserved, not supported
	          this.offset++;
	          break;
	        case 0x05:
	          value = null; //reserved, not supported
	          this.offset++;
	          break;
	        case 0x06:
	          value = undefined; //reserved, not supported
	          this.offset++;
	          break;
	        case 0x08:
	          value = this._parseECMAArrary();
	          break;
	      }
	      return value;
	    }
	  }, {
	    key: '_parseNum',
	    value: function _parseNum() {
	      var numData = this.data.slice(this.offset, this.offset + 8);
	      this.offset += 8;
	      return new DataView(numData.buffer).getFloat64(0);
	    }
	  }, {
	    key: '_parseString',
	    value: function _parseString() {
	      var lengthData = this.data.slice(this.offset, this.offset + 2);
	      var length = lengthData[0] * 256 + lengthData[1];
	      this.offset += 2;
	      var stringData = this.data.slice(this.offset, this.offset + length);
	      this.offset += length;
	      var string = new TextDecoder("utf-8").decode(stringData);
	      return string;
	    }
	  }, {
	    key: '_parseObject',
	    value: function _parseObject() {
	      var val = {};
	      while (this.offset < this.data.length - 2 && this.data[this.offset + 2] !== 0x09) {
	        var key = this._parseString();
	        var valueType = this.data[this.offset];
	        this.offset++;
	        var value = this._switchAmfType(valueType);
	        val[key] = value;
	      }
	      this.offset += 3;
	      return val;
	    }
	  }, {
	    key: '_parseECMAArrary',
	    value: function _parseECMAArrary() {
	      // let lengthData = this.data.slice(this.offset, this.offset + 4);
	      // let length = new DataView(lengthData.buffer).getUint32(0);
	      this.offset += 4;
	      return this._parseObject();
	    }
	  }, {
	    key: '_parseBoolean',
	    value: function _parseBoolean() {
	      this.offset++;
	      return !(this.data[0] === 0x00);
	    }
	  }]);

	  return AmfParser;
	}();

	exports.default = AmfParser;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _mp4Generator = __webpack_require__(22);

	var _mp4Generator2 = _interopRequireDefault(_mp4Generator);

	var _mccreeHelperBrowser = __webpack_require__(13);

	var _mccreeHelperBrowser2 = _interopRequireDefault(_mccreeHelperBrowser);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// Fragmented mp4 remuxer
	var MP4Remuxer = function () {
	  function MP4Remuxer(config) {
	    _classCallCheck(this, MP4Remuxer);

	    this.TAG = 'MP4Remuxer';

	    this.type = 'remuxer';

	    this._config = config || {};
	    this._isLive = this._config.isLive;

	    this._dtsBase = 0;
	    this._dtsBaseInited = false;
	    this._audioDtsBase = Infinity;
	    this._videoDtsBase = Infinity;
	    this._audioNextDts = undefined;
	    this._videoNextDts = undefined;

	    this._audioMeta = null;
	    this._videoMeta = null;
	    this._browser = _mccreeHelperBrowser2.default.uaMatch();
	  }

	  _createClass(MP4Remuxer, [{
	    key: 'init',
	    value: function init(mccree) {
	      this.mccree = mccree;
	      this.logger = mccree.logger;
	      this.observer = mccree.observer;
	      this.events = mccree.events;
	      this.onMediaSegment = mccree.onMediaSegment;
	      this.mccree.initSegment = {};
	      this.mccree.remuxBuffer = {
	        audio: [],
	        video: []
	      };
	      this.observer.on('METADATA_PARSED', this._generateInitailSegment.bind(this));
	      this.observer.on('VIDEODATA_PARSED', this.timmerCallback.bind(this));
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this._dtsBase = 0;
	      this._dtsBaseInited = false;
	      this._audioDtsBase = Infinity;
	      this._videoDtsBase = Infinity;
	      this._audioNextDts = undefined;
	      this._videoNextDts = undefined;

	      this._audioMeta = null;
	      this._videoMeta = null;
	    }
	  }, {
	    key: 'timmerCallback',
	    value: function timmerCallback() {
	      this.mccree.media.tracks.videoTrack && this.mccree.media.tracks.audioTrack && this._generateBoxes();
	    }
	  }, {
	    key: '_generateInitailSegment',
	    value: function _generateInitailSegment() {
	      _mp4Generator2.default.init();
	      this._fixRatio();
	      var audioTrack = this.mccree.media.tracks.audioTrack,
	          videoTrack = this.mccree.media.tracks.videoTrack;
	      audioTrack.isAAC = audioTrack.format === 10;
	      this._generateConfig();
	      // 视频处理
	      if (videoTrack.meta) {
	        var vmovie = _mp4Generator2.default.initSegment([videoTrack]);
	        this.mccree.initSegment.video = vmovie;
	        var amovie = _mp4Generator2.default.initSegment([audioTrack]);
	        this.mccree.initSegment.audio = amovie;
	        this.observer.trigger('INIT_SEGMENT_REMUXED');
	        this._generateBoxes();
	      }
	    }
	  }, {
	    key: '_fixRatio',
	    value: function _fixRatio() {
	      // SPS 错误兼容 / SPS宽高信息错误。转成16:9
	      var mediaInfo = this.mccree.media.mediaInfo || {},
	          videoTrack = this.mccree.media.tracks.videoTrack || {},
	          meta = videoTrack.meta || {},
	          height = meta.codecHeight,
	          width = meta.codecWidth;

	      if (mediaInfo.width === meta.codecWidth && mediaInfo.height === meta.codecHeight) {
	        return;
	      }
	      if (meta.height !== meta.width * 9 / 16) {
	        width = mediaInfo.width ? mediaInfo.width : parseInt(meta.height * 16 / 9);
	        height = mediaInfo.height ? mediaInfo.height : parseInt(meta.width * 9 / 16);
	        meta.codecHeight = height;
	        meta.codecWidth = width;
	        meta.presentHeight = height;
	        meta.presentWidth = width;
	      }
	    }
	  }, {
	    key: '_generateConfig',
	    value: function _generateConfig() {
	      var audioTrack = this.mccree.media.tracks.audioTrack,
	          meta = audioTrack.meta;
	      var config = [],
	          audioObjectType = audioTrack.objectType,
	          samplingIndex = meta.sampleRateIndex,
	          extensionSamplingIndex = void 0,
	          channelConfig = meta.channelCount;
	      var userAgent = navigator.userAgent.toLowerCase();
	      if (userAgent.indexOf('firefox') !== -1) {
	        if (samplingIndex >= 6) {
	          audioObjectType = 5;
	          extensionSamplingIndex = samplingIndex - 3;
	        } else {
	          audioObjectType = 2;
	          config = new Array(2);
	          extensionSamplingIndex = samplingIndex;
	        }
	      } else if (userAgent.indexOf('android') !== -1) {
	        audioObjectType = 2;
	        extensionSamplingIndex = samplingIndex;
	      } else {
	        audioObjectType = 5;
	        extensionSamplingIndex = samplingIndex;
	        if (samplingIndex >= 6) {
	          extensionSamplingIndex = samplingIndex - 3;
	        } else if (channelConfig === 1) {
	          audioObjectType = 2;
	          extensionSamplingIndex = samplingIndex;
	        }
	      }
	      config[0] = audioObjectType << 3;
	      config[0] |= (samplingIndex & 0x0F) >>> 1;
	      config[1] = (samplingIndex & 0x0F) << 7;
	      config[1] |= (channelConfig & 0x0F) << 3;
	      if (audioObjectType === 5) {
	        config[1] |= (samplingIndex & 0x0F) >>> 1;
	        config[2] = (samplingIndex & 0x01) << 7;
	        config[2] |= 2 << 2;
	        config[3] = 0;
	      }
	      meta.config = config;
	      meta.codec = 'mp4a.40.' + audioObjectType;
	    }
	  }, {
	    key: '_generateBoxes',
	    value: function _generateBoxes() {
	      var videoTrack = this.mccree.media.tracks.videoTrack,
	          audioTrack = this.mccree.media.tracks.audioTrack,
	          nextIframe = -1,
	          gop = null,
	          nextDts = -1;

	      var i = 0;

	      if (!this._dtsBaseInited && videoTrack.samples.length > 1 && audioTrack.samples.length > 1) {
	        this._calculateDtsBase(audioTrack, videoTrack);
	      }

	      if (!videoTrack.meta || !audioTrack.meta) {
	        return;
	      }

	      if (videoTrack.samples.length < 15) {
	        return;
	      }

	      var lastPts = videoTrack.samples[0].timestamp + videoTrack.samples[0].compositionTime;
	      var index = 0;
	      nextIframe = 10;

	      if (nextIframe < 1) {
	        return;
	      }

	      if (videoTrack.samples.length <= nextIframe + 1) {
	        return;
	      }

	      var audioLengthLimit = Math.ceil((nextIframe + 1) * videoTrack.meta.refSampleDuration / audioTrack.meta.refSampleDuration) + 1;

	      if (audioTrack.samples.length <= audioLengthLimit || audioTrack.samples.length < nextIframe) {
	        return;
	      }

	      if (videoTrack.samples.length > nextIframe) {
	        nextDts = videoTrack.samples[nextIframe].timestamp;
	        gop = videoTrack.samples.splice(0, nextIframe);
	      }

	      if (gop) {
	        if (this._browser.chrome && this._browser.versionNumber <= 50 || this._browser.mozilla) {
	          gop[0].frameType = 1;
	        }
	        this._generateGop(gop, gop[0].timestamp, nextDts);
	        this._generateBoxes();
	      }
	    }
	  }, {
	    key: '_generateGop',
	    value: function _generateGop(gop, baseDts, nextDts) {
	      var base = baseDts,
	          next = baseDts;
	      var videoTrack = this.mccree.media.tracks.videoTrack,
	          sampleDuration = videoTrack.meta.refSampleDuration;
	      var sampleSize = 0;
	      var mp4Samples = [];
	      // 数据处理
	      for (var i = 0; i < gop.length; i++) {
	        sampleSize += gop[i].data.length;
	      }
	      var bytes = 8 + sampleSize;
	      var mdatbox = new Uint8Array(bytes);
	      mdatbox[0] = bytes >>> 24 & 0xFF;
	      mdatbox[1] = bytes >>> 16 & 0xFF;
	      mdatbox[2] = bytes >>> 8 & 0xFF;
	      mdatbox[3] = bytes & 0xFF;
	      mdatbox.set(_mp4Generator2.default.types.mdat, 4);
	      var offset = 8;
	      // metadata处理
	      for (var _i = 0; _i < gop.length; _i++) {
	        var frame = gop[_i];
	        if (gop[_i + 1]) {
	          next = gop[_i + 1].timestamp;
	          sampleDuration = next - base;
	          base = next;
	        } else {
	          next = nextDts;
	          sampleDuration = next - base;
	          base = next;
	        }

	        // 掉帧检测 音频抽帧
	        if (sampleDuration > videoTrack.meta.refSampleDuration + 1) {
	          this.observer.trigger('FRAME_DROPPED', Math.floor(sampleDuration / videoTrack.meta.refSampleDuration));
	          this.logger.debug(this.TAG, this.type, '检测到视频掉帧 掉帧时间点：' + base);
	        }

	        this.mccree.media.videoDuration += sampleDuration;
	        var mp4Sample = {
	          dts: frame.timestamp - this._dtsBase,
	          pts: frame.compositionTime + frame.timestamp - this._dtsBase,
	          cts: frame.compositionTime,
	          size: frame.data.length,
	          isKeyframe: frame.frameType === 1,
	          duration: sampleDuration + 1,
	          originalDts: base,
	          flags: {
	            isLeading: 0,
	            dependsOn: frame.frameType === 1 ? 2 : 1,
	            isDependedOn: frame.frameType === 1 ? 1 : 0,
	            hasRedundancy: 0,
	            isNonSync: frame.frameType === 1 ? 0 : 1
	          }
	        };
	        mdatbox.set(frame.data, offset);
	        offset += frame.data.length;
	        mp4Samples.push(mp4Sample);
	        this.mccree.remuxBuffer.lastDts = mp4Sample.dts;
	      }
	      var track = {
	        id: videoTrack.id,
	        samples: mp4Samples
	      };
	      videoTrack.sequenceNumber++;
	      var moofbox = _mp4Generator2.default.moof(videoTrack.sequenceNumber, baseDts - this._dtsBase, track);
	      this.mccree.remuxBuffer.video.push({
	        type: 'video',
	        seekable: mp4Samples[0].isKeyframe,
	        timestamp: mp4Samples[0].dts,
	        data: this._mergeBoxes(moofbox, mdatbox)
	      });
	      this.observer.trigger('MEDIA_SEGMENT_REMUXED', gop.length);
	      this._remuxAudio(baseDts, nextDts);
	    }
	  }, {
	    key: '_remuxAudio',
	    value: function _remuxAudio(baseDts, nextDts) {
	      var base = baseDts,
	          next = baseDts;
	      var videoTrack = this.mccree.media.tracks.videoTrack;
	      var audioTrack = this.mccree.media.tracks.audioTrack,
	          sampleDuration = audioTrack.meta.refSampleDuration,
	          audioSamples = audioTrack.samples;
	      var sampleSize = 0;
	      var mp4data = [],
	          mp4Samples = [];
	      // 如果音视频总时长差出一个音频片段长度，则该音频片段废弃。
	      while (audioSamples[0] && audioSamples[0].timestamp + sampleDuration < baseDts) {
	        this.logger.warn(this.TAG, this.type, '检测到音频掉帧/正在进行追帧，追帧时间点：' + audioSamples[0].timestamp);
	        audioSamples.shift();
	      }

	      baseDts = audioSamples[0].timestamp;
	      var audioSample = audioSamples[0];
	      var tep = audioSamples[0].timestamp;
	      while (audioSamples.length > 0 && audioSamples[0].timestamp <= nextDts // 音频片段起始时间小于下一个gop的时间
	      ) {

	        audioSample = audioSamples.shift();

	        if (audioSamples[0]) {
	          base = audioSample.timestamp;
	          next = audioSamples[0].timestamp;
	        } else {
	          base = audioSample.timestamp;
	          next = audioSample.timestamp + sampleDuration;
	        }

	        audioSample.sampleDuration = next - base;

	        this.mccree.media.audioDuration += audioSample.sampleDuration;
	        var mp4Sample = {
	          dts: audioSample.timestamp,
	          pts: audioSample.timestamp,
	          cts: 0,
	          size: audioSample.data.length,
	          duration: audioSample.sampleDuration,
	          originalDts: base,
	          flags: {
	            isLeading: 0,
	            dependsOn: 1,
	            isDependedOn: 0,
	            hasRedundancy: 0
	          }
	        };
	        mp4Samples.push(mp4Sample);
	        sampleSize += audioSample.data.length;
	        mp4data.push(audioSample.data);
	      }

	      while (this.mccree.media.videoDuration - this.mccree.media.audioDuration > audioTrack.meta.refSampleDuration + 1) {
	        this.logger.debug(this.TAG, this.type, '检测到音频掉帧，正在进行补偿 基准时间点：' + base + ' 补偿时间点：' + next);
	        base = next;
	        next = base + audioSample.sampleDuration;
	        var _mp4Sample = {
	          dts: base,
	          pts: base,
	          cts: 0,
	          size: audioSample.data.length,
	          duration: audioSample.sampleDuration,
	          originalDts: base,
	          flags: {
	            isLeading: 0,
	            dependsOn: 1,
	            isDependedOn: 0,
	            hasRedundancy: 0
	          }
	        };
	        this.mccree.media.audioDuration += audioSample.sampleDuration;
	        mp4Samples.push(_mp4Sample);
	        sampleSize += audioSample.data.length;
	        mp4data.push(audioSample.data);
	      }

	      var bytes = sampleSize + 8;
	      var offset = 8;
	      var mdatbox = new Uint8Array(bytes);
	      mdatbox[0] = bytes >>> 24 & 0xFF;
	      mdatbox[1] = bytes >>> 16 & 0xFF;
	      mdatbox[2] = bytes >>> 8 & 0xFF;
	      mdatbox[3] = bytes & 0xFF;
	      mdatbox.set(_mp4Generator2.default.types.mdat, 4);
	      for (var i = 0; i < mp4data.length; i++) {
	        mdatbox.set(mp4data[i], offset);
	        offset += mp4data[i].length;
	      }
	      var track = {
	        id: audioTrack.id,
	        samples: mp4Samples
	      };

	      audioTrack.sequenceNumber++;
	      var moofbox = _mp4Generator2.default.moof(audioTrack.sequenceNumber, baseDts - this._dtsBase, track);
	      this.mccree.remuxBuffer.audio.push({
	        type: 'audio',
	        data: this._mergeBoxes(moofbox, mdatbox)
	      });
	    }
	  }, {
	    key: '_calculateDtsBase',
	    value: function _calculateDtsBase(audioTrack, videoTrack) {
	      if (this._dtsBaseInited) {
	        return;
	      }

	      if (audioTrack.samples && audioTrack.samples.length) {
	        this._audioDtsBase = audioTrack.samples[0].timestamp;
	      }
	      if (videoTrack.samples && videoTrack.samples.length) {
	        this._videoDtsBase = videoTrack.samples[0].timestamp;
	      }

	      this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase);
	      this._dtsBaseInited = true;
	    }
	  }, {
	    key: '_mergeBoxes',
	    value: function _mergeBoxes(moof, mdat) {
	      var result = new Uint8Array(moof.byteLength + mdat.byteLength);
	      result.set(moof, 0);
	      result.set(mdat, moof.byteLength);
	      return result;
	    }
	  }]);

	  return MP4Remuxer;
	}();

	exports.default = MP4Remuxer;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Generate MP4 Box
	*/

	//import Hex from '../utils/hex';

	var UINT32_MAX = Math.pow(2, 32) - 1;

	var MP4 = function () {
	  function MP4() {
	    _classCallCheck(this, MP4);
	  }

	  _createClass(MP4, null, [{
	    key: 'init',
	    value: function init() {
	      MP4.types = {
	        avc1: [], // codingname
	        avcC: [],
	        btrt: [],
	        dinf: [],
	        dref: [],
	        esds: [],
	        ftyp: [],
	        hdlr: [],
	        mdat: [],
	        mdhd: [],
	        mdia: [],
	        mfhd: [],
	        minf: [],
	        moof: [],
	        moov: [],
	        mp4a: [],
	        mvex: [],
	        mvhd: [],
	        pasp: [],
	        sdtp: [],
	        stbl: [],
	        stco: [],
	        stsc: [],
	        stsd: [],
	        stsz: [],
	        stts: [],
	        tfdt: [],
	        tfhd: [],
	        traf: [],
	        trak: [],
	        trun: [],
	        trex: [],
	        tkhd: [],
	        vmhd: [],
	        smhd: [],
	        hvcc: [],
	        '.mp3': []
	      };

	      var i = void 0;
	      for (i in MP4.types) {
	        if (MP4.types.hasOwnProperty(i)) {
	          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
	        }
	      }

	      var videoHdlr = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // pre_defined
	      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
	      ]);

	      var audioHdlr = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // pre_defined
	      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
	      ]);

	      MP4.HDLR_TYPES = {
	        'video': videoHdlr,
	        'audio': audioHdlr
	      };

	      var dref = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x01, // entry_count
	      0x00, 0x00, 0x00, 0x0c, // entry_size
	      0x75, 0x72, 0x6c, 0x20, // 'url' type
	      0x00, // version 0
	      0x00, 0x00, 0x01 // entry_flags
	      ]);

	      var stco = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00 // entry_count
	      ]);

	      MP4.STTS = MP4.STSC = MP4.STCO = stco;

	      MP4.STSZ = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, // sample_size
	      0x00, 0x00, 0x00, 0x00]);
	      MP4.VMHD = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x01, // flags
	      0x00, 0x00, // graphicsmode
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
	      ]);
	      MP4.SMHD = new Uint8Array([0x00, // version
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, // balance
	      0x00, 0x00 // reserved
	      ]);

	      MP4.STSD = new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x01]); // entry_count

	      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
	      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
	      var minorVersion = new Uint8Array([0, 0, 0, 1]);

	      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
	      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
	    }

	    // TODO: support large length & uuid

	  }, {
	    key: 'box',
	    value: function box(type) {
	      var payload = Array.prototype.slice.call(arguments, 1),
	          size = 8,
	          i = payload.length,
	          len = i,
	          result = void 0;
	      // calculate the total size we need to allocate
	      while (i--) {
	        size += payload[i].byteLength;
	      }
	      result = new Uint8Array(size);
	      result[0] = size >> 24 & 0xff;
	      result[1] = size >> 16 & 0xff;
	      result[2] = size >> 8 & 0xff;
	      result[3] = size & 0xff;
	      result.set(type, 4);
	      // copy the payload into the result
	      for (i = 0, size = 8; i < len; i++) {
	        // copy payload[i] array @ offset size
	        result.set(payload[i], size);
	        size += payload[i].byteLength;
	      }
	      return result;
	    }
	  }, {
	    key: 'hdlr',
	    value: function hdlr(type) {
	      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
	    }
	  }, {
	    key: 'mdat',
	    value: function mdat(data) {
	      return MP4.box(MP4.types.mdat, data);
	    }
	  }, {
	    key: 'mdhd',
	    value: function mdhd(timescale, duration) {
	      duration *= timescale;
	      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
	      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
	      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
	      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
	      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
	      0x00, 0x00]));
	    }
	  }, {
	    key: 'mdia',
	    value: function mdia(meta) {
	      return MP4.box(MP4.types.mdia, MP4.mdhd(meta.timescale, meta.duration), MP4.hdlr(meta.type), MP4.minf(meta));
	    }
	  }, {
	    key: 'mfhd',
	    value: function mfhd(sequenceNumber) {
	      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
	      sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]) // sequence_number
	      );
	    }
	  }, {
	    key: 'minf',
	    value: function minf(meta) {
	      if (meta.type === 'audio') {
	        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(meta));
	      } else {
	        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(meta));
	      }
	    }
	  }, {
	    key: 'moof',
	    value: function moof(sn, baseMediaDecodeTime, track) {
	      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
	    }
	    /**
	     * @param tracks... (optional) {array} the tracks associated with this movie
	     */

	  }, {
	    key: 'moov',
	    value: function moov(tracks) {
	      var i = tracks.length,
	          boxes = [];

	      while (i--) {
	        boxes[i] = MP4.trak(tracks[i].meta);
	      }

	      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].meta.timescale, tracks[0].meta.duration)].concat(boxes).concat(MP4.mvex(tracks)));
	    }
	  }, {
	    key: 'mvex',
	    value: function mvex(tracks) {
	      var i = tracks.length,
	          boxes = [];

	      while (i--) {
	        boxes[i] = MP4.trex(tracks[i]);
	      }
	      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
	    }
	  }, {
	    key: 'mvhd',
	    value: function mvhd(timescale, duration) {
	      duration *= timescale;
	      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
	      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
	      var bytes = new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x00, // flags
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
	      timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
	      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
	      0x01, 0x00, // 1.0 volume
	      0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
	      0xff, 0xff, 0xff, 0xff // next_track_ID
	      ]);
	      return MP4.box(MP4.types.mvhd, bytes);
	    }
	  }, {
	    key: 'sdtp',
	    value: function sdtp(track) {
	      var samples = track.samples || [],
	          bytes = new Uint8Array(4 + samples.length),
	          flags = track.flags,
	          i;
	      // leave the full box header (4 bytes) all zero
	      // write the sample table
	      for (i = 0; i < samples.length; i++) {
	        flags = samples[i].flags;
	        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
	      }

	      return MP4.box(MP4.types.sdtp, bytes);
	    }
	  }, {
	    key: 'stbl',
	    value: function stbl(meta) {
	      return MP4.box(MP4.types.stbl, MP4.stsd(meta), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
	    }
	  }, {
	    key: 'avc1',
	    value: function avc1(meta) {
	      var avcc = meta.avcc;
	      var width = meta.codecWidth,
	          height = meta.codecHeight;

	      var data = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, width >>> 8 & 0xFF, // width: 2 bytes
	      width & 0xFF, height >>> 8 & 0xFF, height & 0xFF, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0A, 0x78, 0x71, 0x71, 0x2F, 0x66, 0x6C, 0x76, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xFF, 0xFF]);
	      return MP4.box(MP4.types.avc1, data, MP4.box(MP4.types.avcC, avcc));
	    }
	  }, {
	    key: 'esds',
	    value: function esds(track) {
	      var configlen = track.config.length;
	      return new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags

	      0x03, // descriptor_type
	      0x17 + configlen, // length
	      0x00, 0x01, //es_id
	      0x00, // stream_priority

	      0x04, // descriptor_type
	      0x0f + configlen, // length
	      0x40, //codec : mpeg4_audio
	      0x15, // stream_type
	      0x00, 0x00, 0x00, // buffer_size
	      0x00, 0x00, 0x00, 0x00, // maxBitrate
	      0x00, 0x00, 0x00, 0x00, // avgBitrate

	      0x05 // descriptor_type
	      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
	    }
	  }, {
	    key: 'mp4a',
	    value: function mp4a(track) {
	      var audiosamplerate = track.audiosamplerate;
	      return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, // data_reference_index
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, track.channelCount, // channelcount
	      0x00, 0x10, // sampleSize:16bits
	      0x00, 0x00, 0x00, 0x00, // reserved2
	      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
	      0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
	    }
	  }, {
	    key: 'mp3',
	    value: function mp3(track) {
	      var audiosamplerate = track.audiosamplerate;
	      return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, 0x00, // reserved
	      0x00, 0x01, // data_reference_index
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, track.channelCount, // channelcount
	      0x00, 0x10, // sampleSize:16bits
	      0x00, 0x00, 0x00, 0x00, // reserved2
	      audiosamplerate >> 8 & 0xFF, audiosamplerate & 0xff, //
	      0x00, 0x00]));
	    }
	  }, {
	    key: 'stsd',
	    value: function stsd(meta) {
	      if (meta.type === 'audio') {
	        if (!meta.isAAC && meta.codec === 'mp3') {
	          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(meta));
	        }
	        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(meta));
	      } else {
	        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(meta));
	      }
	    }
	  }, {
	    key: 'tkhd',
	    value: function tkhd(meta) {
	      var id = meta.id,
	          duration = meta.duration * meta.timescale,
	          width = meta.presentWidth,
	          height = meta.presentHeight,
	          upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
	          lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
	      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x07, // flags
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
	      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
	      id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
	      0x00, 0x00, 0x00, 0x00, // reserved
	      upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
	      0x00, 0x00, // layer
	      0x00, 0x00, // alternate_group
	      0x00, 0x00, // non-audio track volume
	      0x00, 0x00, // reserved
	      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
	      width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
	      height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
	      ]));
	    }
	  }, {
	    key: 'traf',
	    value: function traf(track, baseMediaDecodeTime) {
	      var sampleDependencyTable = MP4.sdtp(track),
	          id = track.id,
	          upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
	          lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
	      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF]) // track_ID
	      ), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
	      0x00, 0x00, 0x00, // flags
	      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
	      20 + // tfdt
	      8 + // traf header
	      16 + // mfhd
	      8 + // moof header
	      8), // mdat header
	      sampleDependencyTable);
	    }

	    /**
	     * Generate a track box.
	     * @param track {object} a track definition
	     * @return {Uint8Array} the track box
	     */

	  }, {
	    key: 'trak',
	    value: function trak(meta) {
	      meta.duration = meta.duration || 0xffffffff;
	      return MP4.box(MP4.types.trak, MP4.tkhd(meta), MP4.mdia(meta));
	    }
	  }, {
	    key: 'trex',
	    value: function trex(track) {
	      var id = track.id;
	      return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
	      0x00, 0x00, 0x00, // flags
	      id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
	      0x00, 0x00, 0x00, 0x01, // default_sample_description_index
	      0x00, 0x00, 0x00, 0x00, // default_sample_duration
	      0x00, 0x00, 0x00, 0x00, // default_sample_size
	      0x00, 0x01, 0x00, 0x01 // default_sample_flags
	      ]));
	    }
	  }, {
	    key: 'trun',
	    value: function trun(track, offset) {
	      var samples = track.samples || [],
	          len = samples.length,
	          arraylen = 12 + 16 * len,
	          array = new Uint8Array(arraylen),
	          i,
	          sample,
	          duration,
	          size,
	          flags,
	          cts;
	      offset += 8 + arraylen;
	      array.set([0x00, // version 0
	      0x00, 0x0f, 0x01, // flags
	      len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
	      offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
	      ], 0);
	      for (i = 0; i < len; i++) {
	        sample = samples[i];
	        duration = sample.duration;
	        size = sample.size;
	        flags = sample.flags;
	        cts = sample.cts;
	        array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
	        size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
	        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
	        cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
	        ], 12 + 16 * i);
	      }
	      return MP4.box(MP4.types.trun, array);
	    }
	  }, {
	    key: 'initSegment',
	    value: function initSegment(tracks) {
	      if (!MP4.types) {
	        MP4.init();
	      }
	      var movie = MP4.moov(tracks),
	          result;
	      result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
	      result.set(MP4.FTYP);
	      result.set(movie, MP4.FTYP.byteLength);
	      return result;
	    }
	  }]);

	  return MP4;
	}();

	exports.default = MP4;

/***/ })
/******/ ]);